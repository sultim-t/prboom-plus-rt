<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="UltraEdit-32">
<title>Eternity Engine EDF Reference</title>
</head>

<body bgcolor="#CECECE">

<h2>Eternity Engine EDF Reference v1.5 -- 09/12/05</h2>

<a href="../etcengine.html">Return to the Eternity Engine Page</a>

<ul>
<li><a name="contents"><b>Table of Contents</b></a>
    <ul>
    <li><a href="#intro">Introduction to EDF</a>
    <li><a href="#changes">Changes in EDF 1.5</a>
    <li><a href="#gensyn">General Syntax</a>
    <li><a href="#files">Files</a>
        <ul>
        <li><a href="#root">Specifying the Root EDF File</a>
        <li><a href="#lump">Loading EDF From a WAD Lump</a>
        <li><a href="#estrings">ESTRINGS Lump</a>
        <li><a href="#eterrain">ETERRAIN Lump</a>
        <li><a href="#inc">Including Files</a>
        <li><a href="#inclump">Including Lumps</a>
        <li><a href="#bex">Including BEX Files</a>
        <li><a href="#defs">Default EDF Files</a>
        <li><a href="#fallbacks">Default Fallbacks</a>
        <li><a href="#verbose">Verbose EDF Logging</a>
        </ul>
    <li><a href="#enables">Enable Functions</a>
    <li><a href="#gametypes">Gametype Functions</a>
    <li><a href="#strings">Strings</a>
    <li><a href="#sprnames">Sprite Names</a>
    <li><a href="#spritevars">Sprite-Related Variables</a>
    <li><a href="#pickups">Sprite-Based Pickup Items</a>
    <li><a href="#frames">Frames</a>
    <li><a href="#cmpframes">Compressed Frame Definitions</a>
    <li><a href="#things">Thing Types</a>
    <li><a href="#inherit">Thing Type Inheritance</a>
    <li><a href="#cast">DOOM II Cast Call</a>
    <li><a href="#boss">DOOM II Boss Brain Types</a>
    <li><a href="#sound">Sounds</a>
    <li><a href="#terrain">TerrainTypes</a>
        <ul>
        <li><a href="#splashes">Splash Objects</a>
        <li><a href="#terrain">Terrain Objects</a>
        <li><a href="#floors">Floor Objects</a>
        <li><a href="#tertypes">TERTYPES Lump Processing</a>
        </ul>
    <li><a href="#delta">Delta Structures</a>
    <li><a href="#misc">Miscellaneous Settings</a>
    </ul>
</ul>

<a name="intro">
<hr>
<b>Introduction to EDF</b>
<hr>
</a>
<br>
EDF, which stands for <b>Eternity Definition Files</b>, is a new data specification
language for the Eternity Engine that allows dynamic definition of sprites, thing types,
frames, and other previously internal data. The EDF parser is based on the libConfuse 
configuration file parser library by Martin Hedenfalk, which is also used by GFS and 
ExtraData.
<br><br>
EDF supercedes DeHackEd, and should become the preferred method for "exe" editing in the
future. However, EDF retains features that allow DeHackEd compatibility, and DeHackEd
patches may be loaded over EDF, and even have access to "new" things and frames that are
defined by it.
<br><br>
Each section in this document deals with one of the EDF constructs, as well as showing
their locations in the default EDF files. However, user-made EDF files can, with a few
caveats, contain these structures in any arrangement of files and in any order. User
EDF files do not need to use the same names or arrangements as the defaults, and they
should NEVER be intended to overwrite the Eternity Engine's default files, unless they
are being provided with a customized distribution of the engine itself.
<br><br>
Plans are in place to steadily introduce more features and functionality to EDF in 
future versions of the Eternity Engine, including most notably, weapon definitions.
This documentation will be regularly updated to reflect all changes and additions.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="changes">
<hr>
<b>Changes in EDF 1.5</b>
<hr>
</a>
<br>
<ul>
<li> Added correct_height field for thingtypes.
<li> Added FLIESONDEATH particle effect.
<li> Added custom sound attenuation properties.
<li> Added include_prev function to enable cascading lumps.
<li> ESTRINGS lump processing.
<li> Textual values for thingtype mod field now available.
<li> TerrainTypes
     <ul>
     <li> New terrain.edf module.
     <li> ETERRAIN lump processing.
     <li> splash, terrain, and floor sections.
     <li> TERTYPES lump now deprecated and absorbed into new system.
     </ul>
<li> Improved ifenabled function and added new functions:
     <ul>
     <li> ifenabledany
     <li> ifdisabled
     <li> ifdisabledany
     <li> ifgametype
     <li> ifngametype
     </ul>
<li> Added ability for compressed frames to contain some other fields.
</ul>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="gensyn">
<hr>
<b>General Syntax</b>
<hr>
</a>
<br>
<ul>
<li> EDF is Free-form
     <br><br>
     Whitespace and token positioning are totally free-form in EDF. In addition, semicolons
     are discarded as whitespace and can therefore be used to terminate field assignments, lists,
     etc. as in C or C++. As an example, all of the following are strictly equivalent:
     <pre>     thingtype w00t { mass = 1000 }
     
     thingtype w00t
     {
        mass = 1000;
     }
     
     thingtype
                      w00t
                 {
        mass     =
             1000     ;;;;;;
                     }</pre>
     
     Obviously, you are encouraged to use a clean and consistent format, even though
     it is not required.
     <br><br>
     
<li> Comments
     <br><br>
     EDF files can use three forms of comments:
     <ul>
     <li> # Comments<br>
          Like in DeHackEd, this comment type extends to the end of the line.
     <li> // Comments<br>
          An alternate form of single-line comment, equivalent to #.
     <li> /* */ Comments<br>
          This type of comment is multiline, and extends from the opening /* to the first
          */ found. This type of comment CANNOT be nested. Nested multiline comments will
          cause a syntax error.          
     </ul>
     
     Examples:
     <pre>
     # Single line comment
     
     // Another single line comment
     
     /*
     
        This is a multiline comment
        
     */
     </pre>
<li> Strings
     <br><br>
     Many fields in EDF take strings. Strings, if they do not contain whitespace or any
     character that needs to be escaped, may be unquoted. Unquoted strings additionally
     cannot contain any of the following characters: " ' = { } ( ) + , # / ;<br>
     If any of those characters are found, the unquoted string will be terminated at the
     last valid character.<br><br>
     Example:
     <pre>
     spritenames += { SPR1, SPR2, SPR3 }
     </pre>
     The items SPR1, SPR2, and SPR3 are unquoted strings. Note how the commas serve to
     separate the items in a list, and therefore do not become part of the strings.
     <br><br>
     Many fields more or less require quoted strings. Quoted strings must start and end
     with either single or double quotes (the beginning and ending quote types must match).
     Quoted strings may contain any character except a line break, including those 
     not allowed in unquoted strings. In addition, quoted strings also support the following 
     escape codes for non-typable characters:
     <br><br>
     <ul>
     <li> \n : Hard line break
     <li> \t : Tab
     <li> \b : Backspace
     <li> \a : Beep (causes a sound when printed to the console)
     <li> \\ : Literal \ character.
     <li> \" : Literal ", necessary to use in double-quoted strings only
     <li> \' : Literal ', necessary to use in single-quoted strings only
     </ul>
     <br><br>
     If \ is followed by any other character, the slash is discarded and the next character
     is treated normally (ie, \d becomes d).
     <br><br>
     Examples:
     <pre>
     thingtype w00t
     {
        obituary_normal = "w00ts"
        obituary_melee  = 'says \'w00t\''
     }
     </pre>
     Line Continuation:
     <br><br>
     Starting with Eternity Engine v3.31 Delta, line continuation can be
     used to split quoted strings across multiple lines. The syntax for doing this is
     demonstrated in the following example:
     <pre>
     frame S_MYFRAME
     {
        cmp = "TROO|A|*|6 \
               TroopAttack|@next"
     }
     </pre>
     The "\" character, when followed immediately by a line break, signifies that line
     continuation should be triggered.  Whitespace before the line continuation will be
     included in the string, but any spaces or tabs at the beginning of the next line will
     NOT be included (this is the same as line continuation in BEX files).  This allows the
     following continued parts of the string to be arbitrarily indented for purposes of 
     beautification.  A string can be split across any number of lines in this fashion.
     <br><br>
     
<li> Numbers
     <br><br>
     Most non-string fields in EDF are numbers, either integer or floating-point. Starting
     with EDF 1.1, decimal, octal, and hexadecimal integers will be accepted in all number
     fields. Octal numbers start with a zero, and hexadecimal numbers start with the 
     sequence 0x -- Examples:
     <pre>
     # this is a normal, decimal number (base 10)
     spriteframe = 16
     ...
     # this is an octal number (base 8)
     spriteframe = 020
     ...
     # this is a hexadecimal number (base 16)
     spriteframe = 0x10</pre>
     
     Floating-point numbers must have a decimal point in them, as in "20.0". Floating-point
     numbers are always base 10.
</ul>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="files">
<hr>
<b>Files</b>
<hr>
</a>
<br>
<a name="root">
<hr>
<b>Specifying the Root EDF File</b>
<hr>
</a>
<br>
Eternity supports several methods for locating the root EDF file, which is the only EDF file
loaded directly for parsing.
<ul>
<li> Default -- root.edf
     <br><br>
     If no EDF file is specifically requested through any other method listed here, the engine 
     will load the file "root.edf" from its own directory. The default root.edf contains only
     include statements, which are covered in the next section.
     <br><br>
<li> Command-line Parameter -edf
     <br><br>
     The -edf command-line parameter allows the root EDF file to be specified explicitly, just
     like adding a WAD or DeHackEd file. The argument to the parameter should be exactly one
     complete relative or absolute file path, as in this example:
     <br><br>
     eternity -edf c:\blah\root.edf
     <br><br>
<li> Game File Script (GFS) Specification
     <br><br>
     The new GFS file can specify the root EDF file with the "edffile" keyword. Only one
     EDF file can be specified in a GFS. If -edf is used when a GFS is loaded, the command-line 
     parameter will take precedence. See the <a href="gfs_ref.html">GFS documentation</a> 
     for further information.     
</ul>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="lump">
<hr>
<b>Loading EDF From a WAD Lump</b>
<hr>
</a>
<br>
Starting with EDF 1.4, it is possible to load a WAD lump as the root EDF file. The name of the
root EDF lump must be "EDFROOT", and the newest lump of that name is the one that will be
loaded and parsed. See the section below on including files for information on how this affects
EDF processing. <!-- TODO: add more information once wad vs file specification issue is resolved -->
<br><br>
As of EDF 1.5, selective sets of EDF definitions may also be loaded additively from
separate chains of optional lumps. These lumps are documented under their own sections
below.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="estrings">
<hr>
<b>ESTRINGS Lump</b>
<hr>
</a>
<br>
The ESTRINGS lump is an optional EDF lump which can contain any number of 
<a href="#strings"><b>string</b></a> definitions. String definitions found in the
ESTRINGS lump which already exist will overwrite string definitions with the same
mnemonic. ESTRINGS lumps do not cascade by default, but can be made to do so by using
the <b>include_prev</b> funtion documented below.
<br><br>
Note: it is inappropriate to include an ESTRINGS lump from EDFROOT or from any file
included by it, because ESTRINGS will be processed separately after the root EDF has
been processed. Doing this will cause the definitions to be processed twice.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="eterrain">
<hr>
<b>ETERRAIN Lump</b>
<hr>
</a>
<br>
The ETERRAIN lump is an optional EDF lump which can contain any number of <b>splash</b>,
<b>terrain</b>, and <b>floor</b> definitions. All definitions are additive, and if 
definitions of the same name already exist, they will overwrite. ETERRAIN lumps do not
cascade by default, but can be made to do so by using the <b>include_prev</b> function
documented below.
<br><br>
Note: it is inappropriate to include an ETERRAIN lump from EDFROOT or from any file
included by it, because ETERRAIN will be processed separately after the root EDF has
been processed. Doing this will cause the definitions to be processed twice.
<br><br>
Special note for ETERRAIN: If zero splash, terrain, AND floor objects are defined by
both the root EDF and any ETERRAIN lump processed, the default terrain.edf module will be 
loaded in order to maintain compatibility with older projects. In order to disable this 
behavior, you will need to define at least one splash, terrain, or floor object. This object
can be a dummy which is never used, however.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inc">
<hr>
<b>Including Files</b>
<hr>
</a>
<br>
Use of include files is critical for several purposes. First, it's unorganized and difficult
to maintain EDF files when everything is put haphazardly into one file. Second, through use
of the <b>stdinclude</b> function, user-provided EDF files can include the standard defaults,
without need to duplicate the data in them. This helps keep EDF files compatible with future
versions of the Eternity Engine, besides making your files much smaller.
<br><br>
To include a file or wad lump normally, with a path relative to the current file doing the 
inclusion, use the <b>include</b> function, like in these examples:
<pre>
# include examples

include("myfile.edf")
include("../prevdir.edf");  # remember, semicolons are purely optional
</pre>

This example would include "myfile.edf" from the same directory that the current file is
in, and "prevdir.edf" from the parent directory. It is important to note that this function
can only include files when called from within a file, and it can only include WAD lumps when
called from within a WAD lump. This restriction is necessary due to how the complete path of
the included file must be formed.
<br><br>
In order to remain compatible with future versions of Eternity, and to greatly reduce EDF
file sizes, you can include the standard, default EDF files into your own. To include files
relative to the Eternity executable's directory, use the <b>stdinclude</b> function, like
in this example:
<pre>
stdinclude("things.edf")
</pre>

This would include "things.edf" in the Eternity Engine's folder. This function may be called
from both files and WAD lumps.
<br><br>
Include statements may only be located at the topmost level of an EDF file, and not inside
any section. The following example would not be valid:
<pre>
spritenames =
{
   include("sprnames.txt")
}
</pre>

Note that for maximum compatibility, you should limit EDF file names to MS-DOS 8.3 format 
and use only alphanumeric characters (ie, no spaces). This is not required for Windows or
Linux, but the DOS port of Eternity cannot use long file names.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inclump">
<hr>
<b>Including Lumps</b>
<hr>
</a>
<br>
Two special functions are provided for specifically including EDF lumps. The first function
is <b>lumpinclude</b>. This function includes a wad lump when called from either a file
or a lump. The lump named must exist, or an error will occur. The name must also be no
longer than eight characters. Case of the lump name will be ignored as usual.<br>
Example:
<pre>
lumpinclude("MYEDFLMP")
</pre>

The second function, <b>include_prev</b>, may be called only from within a wad lump.
This function is special in that you do not tell it what lump to include. Rather, it
includes the previously loaded lump of the same name as the current lump being processed,
if and only if such a lump exists. This allows cascading behavior to be enabled for lumps
such as ESTRINGS and ETERRAIN, so that several wads adding such lumps will all load their
definitions. For full flexibility, this does not happen by default. No error will occur
if there is no previous lump -- the function call is simply ignored in that case.<br>
Example:
<pre>
include_prev()
</pre>

The order of lumps is determined first by the order of lumps in each wad, and then by
the order in which wads were loaded. The first lump to be loaded by the game engine
will be the last lump of a given name in the last wad that was loaded. include_prev will
then continue back through lumps of the same name in the same wad, then in the previously
loaded wad, etc.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inc">
<hr>
<b>Including BEX Files</b>
<hr>
</a>
<br>
As of Eternity Engine v3.31 public beta 5, EDF now supports including DeHackEd/BEX files.
Any DeHackEd/BEX files included will be queued in the order they are included, after any
other DeHackEd/BEX files to be processed.  DeHackEd/BEX processing occurs immediately
after EDF processing is complete.  This allows better cohesion between the EDF and BEX
languages, and also allows the user to specify fewer command line parameters or to avoid
the need for a GFS file in some cases.
<br><br>
To include a DeHackEd/BEX file for queueing from EDF, use the <b>bexinclude</b> function,
like in this example:
<pre>
bexinclude("strings.bex")
</pre>

The DeHackEd/BEX file will be included relative to the path of the including EDF file.
There is no <b>stdinclude</b> equivalent for DeHackEd/BEX files, since the engine does not
provide any default BEX files. You <b>cannot</b> call this function from within an EDF WAD 
lump, and an error message will be given if this is attempted.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="defs">
<hr>
<b>Default EDF Files</b>
<hr>
</a>
<br>
This section explains the contents of each of the standard default EDF modules as of
Eternity Engine v3.33.02.
<ul>
<li> root.edf -- includes all other modules
<li> sprites.edf -- contains the sprite names list and sprite-based pickup item definitions
<li> sounds.edf -- contains sound definitions
<li> frames.edf -- contains frame data for use by thing types and player guns
<li> things.edf -- contains thing type definitions
<li> cast.edf -- contains DOOM II cast call definitions
<li> misc.edf -- contains the default list of DOOM II Boss Spawner thing types
<li> terrain.edf -- contains default TerrainTypes definitions
</ul>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="fallbacks">
<hr>
<b>Default Fallbacks</b>
<hr>
</a>
<br>
As a failsafe to allow old EDF modifications to continue working, EDF is now capable of
loading default modules individually when it determines there are zero definitions of certain
sections. The following modules will be loaded as fallbacks when the given conditions are met:
<ul>
<li> sprites.edf -- Loaded when zero sprite names are defined. Note that even if pickup items
     are defined by the user EDF, they will be overridden by the pickup items defined in
     sprites.edf.
<li> sounds.edf -- Loaded when zero sounds are defined.
<li> things.edf -- Loaded when zero thingtypes are defined.
<li> frames.edf -- Loaded when zero frames are defined.
<li> cast.edf -- Loaded when zero cast members are defined.
<li> terrain.edf -- Loaded when zero splash, terrain, and floor objects are defined.
</ul>

Note that misc.edf cannot currently be used as a fallback. Also, this functionality is NOT
meant to allow users to neglect including the minimum required number of sections. This
functionality is only intended to preserve maximum backward compatibility with old EDF
modifications. Relying on fallback behavior in new EDFs may have unexpected results, including
possibly having your new definitions ignored.
<br><br>
As mentioned earlier, to prevent default terrain loading, it will be necessary to define at
least one splash, terrain, or floor object in the root EDF or ETERRAIN lump.
<br><br>
If the engine-default EDF files cannot be found or parsed for any reason, EDF processing will 
cease immediately.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="verbose">
<hr>
<b>Verbose EDF Logging</b>
<hr>
</a>
<br>
Eternity includes a verbose logging feature in the EDF processor that allows a view of
more detailed information on what is occuring while EDF is being processed. This can help
nail down the location of any errors or omissions. To enable verbose EDF logging, use the
command-line parameter <b>-edfout</b>. This will cause Eternity to write an "edfout##.txt" 
log file in its current working directory, where ## is a unique number from 0 to 99.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="enables">
<hr>
<b>Enable Functions</b>
<hr>
</a>
<br>
Starting with EDF 1.2, special functions are provided which allow the user to enable
or disable options within the EDF parser.  The primary use for these functions is to
instruct the parser to skip definitions for game modes other than the one currently
being played. Although all the thing, frame, sound, and sprite definitions will not
conflict and can be loaded with each other, most of the time this is unnecessary and requires
a significant amount of memory which will never be used.  Allowing such definitions
to be discarded during parsing speeds up processing and reduces memory usage. Note that
all of these functions are only valid at the topmost level of an EDF file, and not within
definitions.
<br><br>
Enable Functions
<ul>
<li> <b>enable(&lt;option&gt;)</b>
     <br><br>
     This function enables the provided option from the point of its call onward.
     If the option is already enabled, no change takes place. If an invalid option
     name is provided, an error will occur.
     <br><br>
<li> <b>disable(&lt;option&gt;)</b>
     <br><br>
     This function disables the provided option from the point of its call onward.
     If the option is already disabled, no change takes place. If an invalid option
     name is provided, an error will occur.
     <br><br>
<li> <b>ifenabled(&lt;option&gt;, ...)</b>
     <br><br>
     This function tests if the the provided option is enabled. If so, nothing will
     change. Otherwise, the EDF parser will be instructed to skip forward until it
     finds an <b>endif</b> function (see below). The <b>endif</b> function will then be 
     invoked. If the option provided is invalid, an error will occur. Note that 
     ifenabled/endif pairs cannot be nested.
     <br><br>
     As of EDF 1.5, it is possible to provide any number of valid enable options to
     this function. In the case that more than one enable option is provided, *all*
     specified options must be enabled or the section will be skipped.
     <br><br>
<li> <b>ifenabledany(&lt;option&gt;, ...)</b>
     <br><br>
     New to EDF 1.5, this function tests if *any* of the provided options are enabled.
     If any are, nothing will change. Otherwise, parsing will skip to the next 
     <b>endif</b> function.
     <br><br>
<li> <b>ifdisabled(&lt;option&gt;, ...)</b>
     <br><br>
     New to EDF 1.5, this function tests if *all* of the provided options are disabled.
     If all options are disabled, nothing will change. Otherwise, parsing will skip to
     the next <b>endif</b> function.
     <br><br>
<li> <b>ifdisabledany(&lt;option&gt;, ...)</b>
     <br><br>
     New to EDF 1.5, this function tests if *any* of the provided options are disabled.
     If any of the options are disabled, nothing will change. Otherwise, parsing will
     skip to the next <b>endif</b> function.
     <br><br>
<li> <b>endif()</b>
     <br><br>
     This function marks the end of a section of the file started by an <b>ifenabled</b>,
     <b>ifenabledany</b>, <b>ifdisabled</b>, <b>ifdisabledany</b>, <b>ifgametype</b>, or
     <b>ifngametype</b> call.
     <br><br>
     When any of the aforementioned functions tests an option or value that is not enabled
     or is set to a different value, the parser will look for this function and then call 
     it. This function will cause the parser to start recognizing definitions again from 
     its line onward. If this function does not appear after one of the mentioned
     functions and before the end of the current file, a "missing conditional function" 
     error will occur.
</ul>

Available Options
<ul>
<li> <b>DOOM</b>
     <br><br>
     When this option is enabled, DOOM thing, frame, state, and sound definitions will
     be available. This variable is enabled by default for all user EDFs, but is disabled
     if the game is loaded in Heretic mode and the default root.edf file in Eternity's
     directory is loaded.
     <br><br>
<li> <b>HERETIC</b>
     <br><br>
     When this option is enabled, Heretic thing, frame, state, and sound definitions will
     be available. This variable is enabled by default for all user EDFs, but is disabled
     if the game is loaded in DOOM or DOOM II mode and the default root.edf in Eternity's
     directory is loaded.
</ul>

Notes on Game Mode Options:
<br><br>
As mentioned in their descriptions, the DOOM and HERETIC options will be enabled by
default when user EDF files are loaded. However, user EDF files can explicitly call the
<b>disable</b> function to turn off one or both options before including any of Eternity's
defaults. It is best to do this when you know you will not be using any of one of the
game modes' definitions.
<br><br>
Example:
<pre>
// this thing type is only available if HERETIC is enabled

ifenabled(HERETIC)

thingtype foo { spawnstate = S_FOO1 }

endif()
</pre>

Note on command-line option "-edfenables":

The -edfenables command-line option allows the user to override the default behavior
explicitly and enable all gamemodes' definitions without adding an EDF file.  This does 
not interfere with explicit usage of enable functions in user EDFs, but it does allow 
older DeHackEd patches and WADs which might assume Heretic definitions are available in 
DOOM or vice versa to work.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="gametypes">
<hr>
<b>Gametype Functions</b>
<hr>
</a>
<br>
Starting with EDF 1.5, special functions are provided which allow the EDF parser to
evaluate definitions conditionally depending on the actual type of game being played. This
enables definitions which should only exist in one game type or another to be placed within
a single EDF module without conflict or unnecessary waste of memory and processing time. Note 
that all of these functions are only valid at the topmost level of an EDF file, and not within
definitions.
<br><br>
Gametype Functions
<ul>
<li> <b>ifgametype(&lt;gametype&gt;, ...)</b>
     <br><br>
     This function tests the active gametype against every gametype listed as a parameter.
     If the gametype matches any of the listed types, nothing will change. Otherwise,
     processing will skip to the next <b>endif</b> function.
     <br><br>
<li> <b>ifngametype(&lt;option&gt;, ...)</b>
     <br><br>
     This function tests the active gametype against every gametype listed as a parameter.
     If the gametype matches none of the listed types, nothing will change. Otherwise,
     processing will skip to the next <b>endif</b> function.
</ul>

Gametype Values
<ul>
<li> <b>DOOM</b>
     <br><br>
     This gametype is used for DOOM, Ultimate DOOM, DOOM II, and Final DOOM.
     <br><br>
<li> <b>HERETIC</b>
     <br><br>
     This gametype is used for Heretic and Heretic: Shadow of the Serpent Riders.
</ul>

Notes on Gametype Values:
<br><br>
Gametype values, like the rest of EDF, are case-insensitive. Only values listed above should
be used with the gametype detection functions.
<br><br>
Example:
<pre>
// this TerrainTypes floor is only available when Heretic is being played

ifgametype(HERETIC)

floor { flat = FLATHUH1; terrain = Lava }

endif()
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="strings">
<hr>
<b>Strings</b>
<hr>
</a>
<br>
New to EDF 1.4, strings allow custom messages to be defined which may be used directly by
various game engine subsystems and can be used by other facilities such as the ShowMessage
codepointer.
<br><br>
Each string must be given a unique mnemonic in its definition's header, and this is the name
used to identify the string elsewhere. Each field in the string definition is optional. If a 
field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
As of EDF 1.5, string definitions may also be provided within special lumps named ESTRINGS.
The ESTRINGS lump is parsed separately after the root EDF has been processed, and thus all
string definitions found within the ESTRINGS lump are additive over those defined through
the root EDF. If string definitions within the ESTRINGS lump have the same mnemonic as one
already defined, they will overwrite the original definitions (note this also includes the
numeric id field).
<br><br>
Syntax:
<pre>
string &lt;mnemonic&gt;
{
   num = &lt;unique number&gt;
   val = &lt;string&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>num</b><br>
    Default: -1<br>
    Some subsystems which use EDF strings, such as the ShowMessage codepointer, require the
    strings they use to have a numeric ID. This field sets the optional numeric ID of an EDF
    string to the value given. The default of -1 means that the string has no numeric ID and
    is thus not accessible to such subsystems. This ID number must be unique unless it is
    equal to -1.
<li><b>val</b><br>
    Default = ""<br>
    This is the text which will be stored inside the string object.
</ul>

Restrictions and Caveats:
<ul>
<li> All strings must have a unique mnemonic no longer than 32 characters. They should only 
     contain alphanumeric characters and underscores. Length will be verified, but format will 
     not (non-unique mnemonics will overwrite previous definitions, see below). All string
     mnemonics beginning with an underscore character are reserved for use by strings for
     which the use is engine-defined. See a list below for engine-defined string mnemonics.     
<li> All strings with a numeric ID not equal to -1 must have a unique numeric ID.
     Any strings with a non-unique numeric ID will cause an error.
</ul>

Replacing Existing Strings:
<br><br>
To replace the values of an existing EDF string definition, simply define a new string
with the exact same mnemonic value (as stated above, all strings need a unique mnemonic, so 
duplicate mnemonics serve to indicate that an existing string should be replaced).
<br><br>
Full Example:
<pre>
# Define a string for use by the ShowMessage codepointer

string CyberMsg
{
   num = 0;
   val = "Moooo!";
}

# Define a string for use by the intermission
# See below for notes on reserved mnemonics and how the game engine uses them.

string _IN_NAME_MAP01 { val = "The Slough of Despond" }
</pre>

Engine-Defined String Mnemonics
<br><br>
The following string mnemonics, if defined and properly enabled, will be used by game engine
subsystems directly for the indicated purposes. All reserved mnemonics start with underscores.
Using mnemonics that begin with underscores for your own strings is done at your own risk, 
since this may break compatibility of your patch with future versions of the Eternity Engine.
<br><br>
<pre>
Mnemonic Name or Class           Purpose                         Use Enabled By
-------------------------------------------------------------------------------
_IN_NAME_*                       Intermission map names          MapInfo
-------------------------------------------------------------------------------
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="sprnames">
<hr>
<b>Sprite Names</b>
<hr>
</a>
<br>
Sprite names are defined as a list of string values which must be exactly four characters
long, and should contain only capital letters and numbers.
<br><br>
Syntax:
<pre>
spritenames = { &lt;string&gt;, ... }
</pre>

If this syntax is used more than once, the definition which occurs last during parsing will
take precedence as the original definition of the sprite name list. Values may either be
added by copying the entire list in a new EDF file and adding the new values anywhere in the
list, or by using the following syntax:
<pre>
spritenames += { &lt;string&gt;, ... }
</pre>

This syntax allows the addition of new sprite names to the list without requiring the 
original list to be changed or copied.
<br><br>
The names defined in this list are the names by which a sprite must be referred to in all
other EDF structures. Sprites are the first item to be parsed, regardless of their location,
so like all EDF structures, the list and any additions to it can be placed anywhere.
<br><br>
Note: Sprite names may be duplicated in the list. When this occurs, objects will use the 
corresponding index of the last definition of that sprite name. Avoid this whenever possible,
as it is wasteful and may lead to inconsistencies if DeHackEd patches are subsequently applied.
Previous versions of the EDF documentation inappropriately stated that all sprite names must
be unique. This has never been true, and cannot be made true for purposes of forward 
compatibility (otherwise addition of new sprites to the default sprites.edf could break older
EDFs).
<br><br>
Restrictions and Caveats:
<ul>
<li> There must be at least one sprite name defined.
<li> All sprite names used by other structures must be defined, or an error will occur.
<li> Sprite names will be checked for length, but not for invalid characters.
<li> If compatibility with DeHackEd patches is desired, new sprites should use addition lists.
</ul>
Full example:
<pre>
# defining an original spritenames array (this would replace the default list)
# notice that sprite names never NEED to be quoted, but can be if so desired.
spritenames =
{
   FOO1, FOO2, FOO3, TNT1, PLAY
}

# add a few values in later (maybe near a thing or frames that use them)...
spritenames += { "BLAH", "WOOT" }
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="spritevars">
<hr>
<b>Sprite-Related Variables</b>
<hr>
</a>
<br>
There are two sprite-related variables which may be specified in user EDF files:
<ul>
<li> <b>playersprite</b>
<li> <b>blanksprite</b>
</ul>

<b>playersprite</b> sets the sprite to be used by the default "Marine" player skin. This
must be one of the four-character sprite mnemonics defined in the <b>spritenames</b> array.
If not provided in any EDF file, this variable defaults to the value "PLAY" (and if
PLAY is not defined in that case, an error will occur).
<br><br>
<b>blanksprite</b> sets the sprite to be used when objects or guns attempt to use a sprite
which has no graphics loaded. This must be one of the four-character sprite mnemonics
defined in the <b>spritenames</b> array. If not provided in any EDF file, this variable defaults
to the value "TNT1" (and if TNT1 is not defined in that case, an error will occur).
<br><br>
These values are parsed immediately after the sprite name list is loaded, and can be
placed anywhere. If defined more than once, the last definition encountered takes
precedence. These values must be defined at the topmost level of an EDF file.
<br><br>
Syntax:
<pre>
playersprite = &lt;sprite mnemonic&gt;

blanksprite = &lt;sprite mnemonic&gt;
</pre>

Full example:
<pre>
# set the player skin sprite to BLAH
playersprite = BLAH

# set the blank sprite to FOO1
blanksprite = FOO1
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="pickups">
<hr>
<b>Sprite-Based Pickup Items</b>
<hr>
</a>
<br>
Sprite-based pickup item definitions allow one of a set of predefined pickup effects to be
associated with a sprite, so that collectable objects (with the SPECIAL flag set) using it
will have that effect on the collecting player.
<br><br>
It is currently only possible to associate one effect with a given sprite, but effects can
be assigned to as many sprites as is desired. If a sprite is assigned more than one pickup
effect, the one occuring last takes precedence. There are plans to extend this feature in 
the future to include customizable pickup items, but for now only the predefined effects are
available.
<br><br>
Syntax:
<pre>
pickupitem &lt;sprite mnemonic&gt; { effect = &lt;effect name&gt; }
</pre>

<b>sprite mnemonic</b> must be a valid sprite mnemonic defined in the <b>spritenames</b> list.<br>
<b>effect name</b> may be any one of the following:
<pre>
   ** Note: all ammo amounts double in "I'm Too Young To Die" and "Nightmare!"
   ** Note: weapons give 5 clips of ammo when "Weapons Stay" DM flag is on
   ** Note: dropped weapons give half normal ammo
   
   Effect Name         Item is...               Special effects
  ----------------------------------------------------------------------------
   PFX_NONE            No-op collectable        None
   PFX_GREENARMOR      Green armor jacket       +100% armor
   PFX_BLUEARMOR       Blue armor jacket        +200% armor
   PFX_POTION          DOOM health potion       +1% health
   PFX_ARMORBONUS      Armor bonus              +1% armor
   PFX_SOULSPHERE      Soulsphere               +100% health
   PFX_MEGASPHERE      Megasphere               200% health/armor
   PFX_BLUEKEY         DOOM Blue key card
   PFX_YELLOWKEY       DOOM Yellow key card
   PFX_REDKEY          DOOM Red key card
   PFX_BLUESKULL       DOOM Blue skull key
   PFX_YELLOWSKULL     DOOM Yellow skull key
   PFX_REDSKULL        DOOM Red skull key
   PFX_STIMPACK        Stimpack                 +10% health
   PFX_MEDIKIT         Medikit                  +25% health
   PFX_INVULNSPHERE    Invulnerability Sphere   Temporary god mode
   PFX_BERZERKBOX      Berzerk Box              Super strength
   PFX_INVISISPHERE    Invisibility Sphere      Temporary partial invis.
   PFX_RADSUIT         Radiation Suit           No nukage damage
   PFX_ALLMAP          Computer Map             All of automap revealed
   PFX_LIGHTAMP        Light Amp Visor          All lights at full level
   PFX_CLIP            Clip                     +10 Bullets
   PFX_CLIPBOX         Clip box                 +50 Bullets
   PFX_ROCKET          Rocket                   +1 Rocket
   PFX_ROCKETBOX       Box of Rockets           +10 Rockets
   PFX_CELL            Cells                    +20 Cells
   PFX_CELLPACK        Cell pack                +100 Cells
   PFX_SHELL           Shells                   +4 Shells
   PFX_SHELLBOX        Box of Shells            +20 Shells
   PFX_BACKPACK        Backpack                 Max ammo *= 2, +1 clip all ammo
   PFX_BFG             BFG                      BFG weapon, +2 clips cells
   PFX_CHAINGUN        Chaingun                 Chaingun weapon, +2 clips bull.
   PFX_CHAINSAW        Chainsaw                 Chainsaw weapon
   PFX_LAUNCHER        Rocket launcher          Rocket launcher weapon, +2 rock.
   PFX_PLASMA          Plasma Gun               Plasma gun weapon, +2 clips cells
   PFX_SHOTGUN         Shotgun                  Shotgun weapon, +2 clips shells
   PFX_SSG             Super Shotgun            SSG weapon, +2 clips shells
   PFX_HGREENKEY       Heretic Green key        ** Gives both DOOM red keys
   PFX_HBLUEKEY        Heretic Blue key         ** Gives both DOOM blue keys
   PFX_HYELLOWKEY      Heretic Yellow key       ** Gives both DOOM yellow keys
   PFX_HPOTION         Heretic Potion           +10% health
   PFX_SILVERSHIELD    Silver Shield            +100% Heretic armor (stronger)
   PFX_ENCHANTEDSHIELD Enchanted Shield         +200% Heretic armor (stronger)
   PFX_BAGOFHOLDING    Bag of Holding           No effect yet
   PFX_HMAP            Map Scroll               All of automap revealed
   PFX_TOTALINVIS      Total InvisiSphere       Temporary total invisibility
  -----------------------------------------------------------------------------
</pre>

Full example:
<pre>
# define a couple of sprite-based pickups
pickupitem FOO2 { effect = PFX_TOTALINVIS }
pickupitem FOO3 { effect = PFX_LAUNCHER }

# redefine an existing pickup effect (don't forget free-form syntax...)
pickupitem FOO3 
{ 
   effect = PFX_ENCHANTEDSHIELD;
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="frames">
<hr>
<b>Frames</b>
<hr>
</a>
<br>
Frames, also known as states, define the animation and logic sequences for thing types and
player weapons.
<br><br>
Each frame must be given a unique mnemonic in its definition's header, and this is the name
used to identify the frame elsewhere. Each field in the frame definition is optional. If a 
field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
If a frame's mnemonic is not unique, the latest definition of a frame with that mnemonic
replaces any earlier ones. As of EDF 1.1 (Eternity Engine v3.31 public beta 4), frame 
mnemonics are completely case-insensitive. This means that a frame defined with a mnemonic 
that differs from an existing one only by case of letters will overwrite the original frame.
<br><br>
Note that the order of frame definitions in EDF is not important. For purposes of DeHackEd and
parameterized codepointers, the number used to access a frame is now defined in the frame itself.
For the original frames, these happen to be the same as their order.
<br><br>
User frames that need to be accessible from DeHackEd or from parameterized codepointers can 
define a <b>unique</b> DeHackEd number, which for purposes of forward compatibility, should 
be greater than or equal to 10000, and less than 32768. User frames not needing access via 
DeHackEd can be given a DeHackEd number of -1. This causes them to be inaccessible to these
features. It is the user's responsibility to allocate and keep track of custom DeHackEd 
numbers -- any frame can be given one, but most will not need it.
<br><br>
Syntax:
<pre>
# Remember that all fields are optional and can be in any order.

frame &lt;unique mnemonic&gt;
{
   sprite         = &lt;sprite mnemonic&gt;
   spriteframe    = &lt;number&gt; OR &lt;character&gt;
   fullbright     = &lt;boolean&gt;
   tics           = &lt;number&gt;
   action         = &lt;bex codeptr name&gt;
   nextframe      = &lt;frame mnemonic&gt; OR &lt;nextframe specifier&gt;
   misc1          = &lt;special field&gt;
   misc2          = &lt;special field&gt;
   particle_event = &lt;event name&gt;
   args           = { &lt;special field&gt;, ... }
   dehackednum    = &lt;unique number&gt;
   cmp            = &lt;compressed frame definition&gt;
}
</pre>

Explanation of fields:
<ul>
<li><b>sprite</b><br>
    Default = "BLANK" (this special value can be used to access the blanksprite value)<br>
    Sets the sprite displayed when this frame is used. Must be a sprite mnemonic defined in
    the <b>spritenames</b> list, or the special value "BLANK".
<li><b>spriteframe</b><br>
    Default = 0<br>
    Sets the frame of the sprite displayed. A frame value of 0 displays the graphic that is
    named with an A in wads, 1 displays B, and so forth. Starting with EDF 1.1, you may also
    specify a character from A to Z or one of [, \, or ], matching the lump name.<br>
    Examples:
    <pre>
    # These are equivalent
    spriteframe = 0
    ....
    spriteframe = A</pre>
<li><b>fullbright</b><br>
    Default = false<br>
    Determines if this frame renders a sprite at fullbright light level. Can be set to any
    of the values yes/no, on/off, or true/false, with the obvious meanings.
<li><b>tics</b><br>
    Default = 1<br>
    Determines the length of time an object remains in this frame. A tic is equivalent to
    1/35th of a second, so 35 tics is 1 second. A frame with 0 tics is passed through
    instantly. A frame with -1 tics is stayed in forever (see nextframe below). This field
    is not used for some player weapon frames.
<li><b>action</b><br>
    Default = "NULL"<br>
    Sets the action to be taken when this frame is entered. This is also known as the
    codepointer, and uses the same mnemonics that are used in the 
    <a href="dehref.html#codeptr">BEX Codepointer Block</a>. Also see the
    <a href="codeptrs.html">Eternity Engine Definitive Codepointer Reference</a>
    for detailed information on what every available codepointer does.
<li><b>nextframe</b><br>
    Default = S_NULL<br>
    Sets the frame to which the object will transfer when this one has been passed. Note
    that if the frame's tics value is -1, this field will never be used. This field must be
    a valid frame mnemonic. It can be the name of the same or any other frame.<br>
    Starting with EDF 1.1, you may also specify one of several special reserved words for
    this field:
    <ul>
    <li><b>@next</b> -- sets nextframe to the next frame defined in EDF
    <li><b>@prev</b> -- sets nextframe to the previous frame defined in EDF
    <li><b>@this</b> -- sets nextframe to the same frame (the one being processed)
    <li><b>@null</b> -- sets nextframe to the S_NULL frame
    </ul>
    <br>
    Note that if @next or @prev are used for the last or first frames respectively, an error
    will occur.
<li><b>misc1</b><br>
    Default = "0"<br>
    This is a special field which can accept a wide range of special value types. See the
    information below on special fields.
<li><b>misc2</b><br>
    Default = "0"<br>
    This is a special field which can accept a wide range of special value types. See the
    information below on special fields.
<li><b>particle_event</b><br>
    Default = pevt_none<br>
    This field lists the name of a particle event that will be triggered by an object when
    it enters this frame. Valid particle event names are as follows:
    <pre>
    Effect name           Effect
    --------------------------------------
    pevt_none             No effect
    pevt_rexpl            Rocket Burst
    pevt_bfgexpl          BFG Burst
    </pre>
<li><b>args</b><br>
    Default = All values will be set to 0<br>
    This list will accept up to five special values. If more than five are provided, only
    the first five will be used. If less than 5 are provided, any not provided are set to
    zero. This list corresponds to the DeHackEd fields Args1 through Args5, in order. The
    purpose of this list is to serve as a set of arguments to parameterized codepointers.
    See the information on special fields below.
<li><b>dehackednum</b><br>
    Default = -1<br>
    As explained above, this is the number which must be used to refer to this frame in
    DeHackEd patches. -1 means that the frame is not accessible from DeHackEd, or by 
    parameterized codepointers that require a frame DeHackEd number. User-defined frames
    should currently only use DeHackEd numbers between 10000 and 32768, or simply use -1
    if no DeHackEd functionality is required. This number must be unique unless it is -1.
<li><b>cmp</b><br>
    Default = none<br>
    The cmp field is used to provide a compressed definition for the normal fields of this
    frame. When the cmp field is provided, all other fields except <b>misc1</b>, <b>misc2</b>,
    <b>args</b>, and <b>dehackednum</b> will be ignored. See the 
    <a href="#cmpframes">Compressed Frame Definitions</a> section below for full information.
    Note that this field is NOT accepted inside framedelta blocks. This field is new to EDF 
    1.1. The ability to specify misc and args fields along with a cmp field is new to EDF 1.5.
    <br>
    Note: When a cmp field is defined, misc and args fields will be treated as though they
    are defined in a <b>framedelta</b> block, meaning that if the cmp field specifies any
    misc or args values, the values specified in misc and args will overwrite them only if the
    fields are present.
</ul>

Special Fields:
<br><br>
The special fields misc1 and misc2, as well as all five usable values of the args list, can
take special values of the following type by using prefix:value syntax as shown:
<ul>
<li><b>frame:&lt;frame mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated frame. If the indicated frame has
     no unique DeHackEd number, the S_NULL state will be stored and a warning will be issued
     to the verbose EDF log.<br>
     Example:
     <pre>
     misc1 = frame:S_FOOBAR1
     </pre>
<li><b>thing:&lt;thing mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated thing type. If the indicated thing has
     no unique DeHackEd number, the Unknown thing type will be stored and a warning will be issued
     to the verbose EDF log.<br>
     Example:
     <pre>
     misc1 = thing:BaronOfHell
     </pre>
<li><b>sound:&lt;sound mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated sound. See the 
     <a href="dehref.html#sndtable">Internal Sound List</a> 
     in the Eternity DeHackEd/BEX Reference for a list of documented sound mnemonics,
     or view the default sounds.edf file. If the indicated sound has no unique DeHackEd
     number, the dummy sound "none" will be stored and a warning will be issued to the verbose
     EDF log.<br>
     Example:
     <pre>
     misc2 = sound:pistol
     </pre>
<li><b>flags:&lt;flag list&gt;</b>
<li><b>flags2:&lt;flag list&gt;</b>
<li><b>flags3:&lt;flag list&gt;</b><br>
    Translated into the corresponding integer value for the appropriate thing
    flags field (needed for some parameterized codepointers). See the
    <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the
    Eternity DeHackEd/BEX Reference for full information. The format here is the same
    with the exception that if white space or restricted characters are put into a flag 
    list, the entire special field value MUST be enclosed in quotation marks.<br>
    Examples:
    <pre>
    args = { 1, flags:SOLID|SHOOTABLE|COUNTKILL }
    
    # this needs quotations here, whereas it doesn't in a BEX file, because both
    # whitespace and + characters aren't allowed in unquoted strings in EDF
    
    misc2 = "flags2:LOGRAV + BOSS"
    </pre>
<li><b>bexptr:&lt;codepointer mnemonic&gt;</b><br>
    Translated into an internal codepointer table index. Used by parameterized codepointers
    that request another codepointer which they will call directly, such as PlayerThunk. The
    values to which codepointer mnemonics are translated are *not* published, and could
    change from version to version. Therefore, you *must* use EDF for these types of
    codepointers.<br>
    Example:
    <pre>
    args = { bexptr:Chase }
    </pre>
<li><b>string:&lt;string mnemonic&gt;</b><br>
    Translated into the corresponding numeric id of the indicated string object. If no such
    string exists, a warning will be issued to the verbose EDF logfile and the numeric id of
    zero will be substituted (all facilities that use EDF strings by number are fail-safe, so 
    if string zero does not exist, nothing will happen). String mnemonic support was new to
    EDF 1.4, but was accidentally omitted from this documentation until EDF 1.5.<br>
    Example:
    <pre>
    args = { string:CyberMsg }
    </pre>
<li><b>No Prefix</b><br>
    If no prefix is given for a value, it is interpreted as an integer number via the
    C function "strtol" (meaning it may be decimal, octal, or hexadecimal).<br>
    Examples:
    <pre>
    misc1 = 32768
    misc2 = -45
    args = { 1, 1, 2, 3, 5 }
    </pre>
<li><b>Invalid prefixes</b><br>
    If any prefix is used other than the ones listed here, an error will occur.
</ul>

Restrictions and Caveats:
<ul>
<li> At least one frame must be defined.
<li> The S_NULL frame must be defined (it may be the only frame, but it must exist).
<li> All frames must have a unique mnemonic no longer than 40 characters. Frame mnemonics are
     case-insensitive. They should only contain alphanumeric characters and underscores. All 
     other punctuation marks are explicity reserved for extended syntactical use. Length will 
     be verified, but format will not (non-unique mnemonics will overwrite previous definitions, 
     see below).
<li> All frames with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     This will be verified.
</ul>

Replacing Existing Frames:
<br><br>
To replace the values of an existing frame, simply define a new frame with the exact same
mnemonic value (as stated above, all frames need a unique mnemonic, so duplicate mnemonics
serve to indicate that an existing frame should be replaced).

EDF 1.1 also adds delta structures, which allow fields of existing frames to be edited
without replacing all values in those frames. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# define some new frames
frame BLAH1
{
   sprite = FOO1
   fullbright = true
   tics = 12
   nextframe = BLAH2
}

frame BLAH2
{
   sprite = FOO1
   tics = 12
   nextframe = BLAH1
}

# Overwrite an existing frame (since BLAH1 is already defined above...)
# Also remember that mnemonics are case-insensitive!
frame blah1
{
   sprite = FOO1
   fullbright = true
   tics = 12
   action = HticExplode
   args = { 1 }
   nextframe = S_NULL
}
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="cmpframes">
<hr>
<b>Compressed Frame Definitions</b>
<hr>
</a>
<br>
Compressed frame definitions are a new feature in EDF 1.1 that allows a shorthand syntax for
specifying the fields of a frame block.
<br><br>
A compressed frame definition resides inside a normal EDF frame definition, using the
<b>cmp</b> keyword outlined in the syntax of the <b><a href="#frames">frame</a></b> block.
It accepts a single string value with an extended syntax, and the value of all other fields
in the frame block except for the <b>dehackednum</b> can be set via this string.  When the cmp
field is present in a frame block, all other fields except <b>misc1</b>, <b>misc2</b>, 
<b>args</b>, and <b>dehackednum</b> are ignored.
<br><br>
Note that the <b>cmp</b> field is NOT accepted inside framedelta blocks.
<br><br>
As of Eternity Engine v3.31 Delta, the format of cmp fields has been relaxed to allow arbitrary
whitespace, quoted values, and line continuation. Line continuation was discussed in the 
<a href="#gensyn">General Syntax</a> section, but the new changes to the cmp field are 
discussed below. Note that all existing cmp strings are still accepted as valid; the new 
features simply allow for greater flexibility.
<br><br>
Syntax:
<pre>
frame
{
   cmp = &lt;compressed frame definition&gt;
}
</pre>

The compressed frame definition string has the following syntax:

<pre>
"sprite|spriteframe|fullbright|tics|action|nextframe|particle_event|misc1|misc2|args1-5"
</pre>

Fields MUST be provided in the order given, but any number of fields can be left off at
the end of the definition, and those fields will receive their normal default values. To
let an internal field default, you must use the special reserved value "*" for that field.
<br><br>
Each field is delimited by pipe or, as of EDF v1.4, comma characters, and field values may NOT
contain pipe or comma characters, unless, starting with EDF v1.3, the entire field value is 
enclosed in single or escaped double quotation marks. Beginning with EDF v1.3, extraneous 
whitespace IS allowed between field delimiters and their values. Only whitespace which is 
enclosed within quotation marks will be interpreted as part of a field's value, so if BEX flags
strings are to use pipes, commas, or spaces to separate flags, they must be enclosed with 
quotations. When using quoted values, the beginning and end quotation mark type must match 
(ie, if it starts with ', it must end with ', and if it starts with \", it must end with \").
<br><br>
The fullbright field has a special caveat within compressed frame definitions. Any value
beginning with the letter T (small or capital) will be interpreted to mean "true", and any
other value, including the default, will be interpreted to mean "false".
<br><br>
Otherwise, all fields can accept exactly the same types and ranges of values that they
normally accept when specified separately within a frame block. This includes letters and
numbers for the spriteframe field, special keywords for the nextframe field, and prefix:value
syntax for misc1, misc2, and the five args fields.
<br><br>
<b>Examples:</b>
<pre>
# this is a compressed frame definition which specifies ALL the values

frame FOOBAR1 { cmp = "AAAA|A|F|6|Look|@next|pevt_none|0|0|0|0|0|0|0" }

# this is an equivalent frame definition, using default specifiers and
# leaving off defaulting fields at the end of the definition. This frame
# and the above mean the EXACT same thing.

frame FOOBAR1 { cmp = "AAAA|*|*|6|Look|@next" }

# here is a complicated example using a parameterized codepointer

#                                                          Args start here
#                                                          |
#                                                          V
frame FOOBAR2 { cmp = "TROO|6|*|6|MissileAttack|@next|*|*|*|thing:DoomImpShot|*|*|20" }
</pre>

<b>Bad Frame Examples:</b>
<br><br>
Some illegal compressed frame definitions would include the following. Don't make these
mistakes:
<pre>
# This is wrong, field values may NOT be empty -- use "*" to indicate a default.

frame BAD1 { cmp = "AAAA|||6|Look|@next" }

# This is wrong because BEX flag fields CANNOT use '|' or ',' inside compressed frames, unless
# they are surrounded by escaped quotation marks.

frame BAD3 { cmp = "AAAA|B|T|23|SomePointer|*|*|*|flags:SOLID|SHOOTABLE|COUNTKILL" }

# This is wrong because you cannot leave off fields at the beginning.

frame BAD4 { cmp = "Look|@next" }

# This is wrong because fields must be in the correct order.

frame BAD5 { cmp = "6|TROO|*|6|thing:DoomImp|@next|MissileAttack|*|20" }
</pre>

<b>Examples Using EDF 1.3 and Later Extended Syntax:</b>
<br><br>
The following frames would have been invalid prior to EDF v1.3, but are now accepted due to
the new relaxation of the cmp field format:
<pre>
# Arbitrary whitespace is now allowed, and is ignored outside of quoted values:

frame NOWGOOD1 { cmp = "AAAA | * | * | 6 | Look | @next" }

# Values may now be quoted using single or escaped double quotation marks so 
# that they can contain normally ignored or reserved characters.
# This allows BEX flags strings to contain pipes, commas, and/or spaces:

frame NOWGOOD2 { cmp = "AAAA | * | * | 6 | Look | @next | * | 'flags:SHOOTABLE | SOLID | COUNTKILL'" }
frame NOWGOOD3 { cmp = "AAAA | * | * | 6 | Look | @prev | * | \"flags:SHOOTABLE | SOLID | COUNTKILL\"" }

# EDF line continuation may be used inside any quoted string, including cmp field values.
# This frame is completely equivalent to the first example above:

frame NOWGOOD4 
{ 
   cmp = "AAAA | *    | *    | \
          6    | Look | @next" 
}

# As of EDF v1.4, you can use commas instead of pipes as delimiters. This was added
# by user request because it makes some definitions more readable. When using commas, the
# entire cmp field must be quoted without exception, since commas cannot be used in 
# unquoted strings.

frame NOWGOOD5 { cmp = "AAAA, *, *, 6, Look, @next" }

</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="things">
<hr>
<b>Thing Types</b>
<hr>
</a>
<br>
Thing types define monsters, lamps, control points, items, etc -- anything that moves, occupies
space, can display a sprite, or is useful for singling out locations.
<br><br>
Each thing type must be given a unique mnemonic in its definition's header, and this is the name
used to identify the thing type elsewhere. Each field in the thing type definition is optional. 
If a field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
If a thing type's mnemonic is not unique, the latest definition of a thing type with that mnemonic
replaces any earlier ones. See the information below for more on this. As of EDF 1.1 
(Eternity Engine v3.31 public beta 4), thing type mnemonics are completely case-insensitive. This 
means that a thing type defined with a mnemonic that differs from an existing one only by case of 
letters will overwrite the original type.
<br><br>
Note that the order of thing type definitions in EDF is not important. For purposes of DeHackEd,
the number used to access a thing type is now defined in the type itself. For the original
thing types, these happen to be the same as their order.
<br><br>
User thing types that need to be accessible from DeHackEd or by parameterized codepointers can 
define a <b>unique</b> DeHackEd number, which for purposes of forward compatibility, should be
greater than or equal to 10000 and less than 32768. User types not needing access via DeHackEd 
or by parameterized codepointers can be given a DeHackEd number of -1. This causes them to be
inaccessible to DeHackEd and to parameterized codepointers. It is the user's responsibility to
allocate and assign DeHackEd numbers to thingtypes. All custom thingtypes may be given a
DeHackEd number, but most will not need one.
<br><br>
Syntax:
<pre>
# Remember that all fields are optional and can be in any order.

thingtype &lt;unique mnemonic&gt;
{
   inherits        = &lt;thing type mnemonic&gt;
   doomednum       = &lt;number&gt;
   spawnstate      = &lt;frame mnemonic&gt;
   spawnhealth     = &lt;number&gt;
   seestate        = &lt;frame mnemonic&gt;
   seesound        = &lt;sound mnemonic&gt;
   reactiontime    = &lt;number&gt;
   attacksound     = &lt;sound mnemonic&gt;
   painstate       = &lt;frame mnemonic&gt;
   painchance      = &lt;number&gt;
   painsound       = &lt;sound mnemonic&gt;
   meleestate      = &lt;frame mnemonic&gt;
   missilestate    = &lt;frame mnemonic&gt;
   crashstate      = &lt;frame mnemonic&gt;
   deathstate      = &lt;frame mnemonic&gt;
   xdeathstate     = &lt;frame mnemonic&gt;
   deathsound      = &lt;sound mnemonic&gt;
   speed           = &lt;number&gt; OR &lt;floating-point number&gt;
   radius          = &lt;floating-point number&gt;
   height          = &lt;floating-point number&gt;
   correct_height  = &lt;floating-point number&gt;
   mass            = &lt;number&gt;
   damage          = &lt;number&gt;
   activesound     = &lt;sound mnemonic&gt;
   flags           = &lt;flag list&gt;
   flags2          = &lt;flag list&gt;
   flags3          = &lt;flag list&gt;
   cflags          = &lt;flag list&gt;
   addflags        = &lt;flag list&gt;
   remflags        = &lt;flag list&gt;
   raisestate      = &lt;frame mnemonic&gt;
   translucency    = &lt;number&gt; OR &lt;percentage&gt;
   bloodcolor      = &lt;number&gt;
   fastspeed       = &lt;number&gt; OR &lt;floating-point number&gt;
   nukespecial     = &lt;BEX codepointer mnemonic&gt;
   particlefx      = &lt;particle effect flag list&gt;
   droptype        = &lt;thing type mnemonic&gt;
   mod             = &lt;MOD name&gt; OR &lt;number&gt;
   obituary_normal = &lt;string&gt;
   obituary_melee  = &lt;string&gt;
   translation     = &lt;number&gt; OR &lt;translation table lump name&gt;
   dmgspecial      = &lt;dmgspecial name&gt;
   skinsprite      = &lt;sprite mnemonic&gt;
   dehackednum     = &lt;unique number&gt;
}
</pre>

Explanation of fields:
<ul>
<li><b>inherits</b><br>
    No default value<br>
    Sets the thing type from which this type will inherit values. See the
    <a href="#inherit">Thing Type Inheritance</a> section below for full information on how
    thing type inheritance works.    
<li><b>doomednum</b><br>
    Default = -1<br>
    Sets the ID used to identify this thing type in maps. For example, when a map calls for a 
    thing with ID 2003, the game engine will find the thing type which has that number in this 
    field. Every thing that will be spawned on maps must have a unique doomednum. Things which 
    are not spawned on maps, such as fireballs, can be given the default doomednum of -1.<br>
    For purposes of forward compatibility, user-defined thing types should use doomednums
    greater than or equal to 20000 and less than 32768. All other doomednum ranges are considered
    to be reserved as outlined here. The purposes of various blocks may be relaxed in the
    future for purposes of internal use, so these are only rough guidelines provided for
    completeness.
    <pre>
     Doomednum Range     Usage
    ---------------------------------------------------------------
        0                No-op, no thing will be spawned at all
        1 -  4999        Original DOOM things and some extensions
     5000 -  5999        BOOM-style control points
     6000 -  6999        Reserved for port use
     7000 -  7999        Things translated from other games
     8000 -  8999        Reserved for port use
     9000 -  9999        zdoom-style control points
    10000 - 19999        Reserved for port use
    20000 - 32767        Reserved for EDF</pre>
<li><b>spawnstate</b><br>
    Default = S_NULL<br>
    Sets the frame which a thing starts in when it is spawned. Monsters generally use this 
    frame to stand still and look for targets.
<li><b>spawnhealth</b><br>
    Default = 1000<br>
    Sets a thing's maximum amount of life. It is only used for things which can be shot.
<li><b>seestate</b><br>
    Default = S_NULL<br>
    Sets the frame which a monster will jump to when it sees or hears a target. 
    Also called walking frames, or first moving frame. 
<li><b>seesound</b><br>
    Default = none<br>
    Sets the sound that a monster will play when it awakens. This sound is also played by 
    missiles when they are shot. (Note: "none" is a special mnemonic for no sound)
<li><b>reactiontime</b><br>
    Default = 8<br>
    Sets an amount of time that a thing must wait under certain circumstances. Monsters use 
    this value as a means to control their rate of attack. This value is also used as an 
    internal field for varying purposes, but those uses are not editable.
<li><b>attacksound</b><br>
    Default = none<br>
    Sets a sound used by some monster attacks, including the Lost Soul's charge.
<li><b>painstate</b><br>
    Default = S_NULL<br>
    Sets the frame a thing may randomly enter when it has been injured.
<li><b>painchance</b><br>
    Default = 0<br>
    Sets the chance out of 255 that this thing will enter its painstate when it is injured. 
    A thing with 0 painchance will never feel pain, whereas a thing with 255 painchance will 
    always feel pain. If a thing has a painchance greater than zero, it should have a valid 
    painstate, otherwise it will disappear forever. 
<li><b>painsound</b><br>
    Default = none<br>
    Sets the sound played by the Pain codepointer when this thing uses it. Monsters and the 
    player always call Pain from their painstate.
<li><b>meleestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, monsters chasing a target will attempt to close to melee 
    range quickly. When they determine they are within 64 units of their target, they may 
    randomly enter this frame to perform a melee attack.
<li><b>missilestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, monsters chasing a target will randomly enter it to perform 
    a missile attack.
<li><b>crashstate</b><br>
    Default = S_NULL<br>
    When a thing with this state dies and then subsequently hits the ground, it will enter
    this state. If this state S_NULL, it is not used. New to EDF 1.3.
<li><b>deathstate</b><br>
    Default = S_NULL<br>
    When a thing dies normally, it will enter this state. If the state is S_NULL, the thing 
    will disappear forever.
<li><b>xdeathstate</b><br>
    Default = S_NULL<br>
    If a thing dies by taking enough damage that its health is equal to its negated spawnhealth 
    value, it will enter this frame instead of its deathstate. This is also known as gibbing, or 
    extreme death. If this frame is S_NULL, the thing will always die normally.
<li><b>deathsound</b><br>
    Default = none<br>
    Sound played by the Scream codepointer. Used to play monster death sounds.
<li><b>speed</b><br>
    Default = 0<br>
    Value used by monsters as a movement delta per walking frame. The monster will move by an 
    amount relative to this value each time it uses the Chase codepointer. For missiles, this 
    value is a fixed-point number (multiplied by 65536), and represents a constant speed by 
    which the missile advances every game tic. Missile speed is not affected by the missile 
    frame durations, whereas monster walking speed is.<br>
    Starting with EDF 1.1, this field also supports floating-point values. When a floating-point
    value is provided, it will be translated into the corresponding fixed-point value. This
    means that a value of 10.0 is equivalent to the integer value 655360 (10*65536). It is NOT
    equivalent to 10. This distinction is very important. Small integer speed values are
    appropriate for monsters, whereas floating-point values will be suitable only for missiles.
<li><b>radius</b><br>
    Default = 20.0<br>
    Floating-point value that represents the radius of this thing type. A thing can fit into 
    corridors which are at least as wide as this value times two, plus one unit (ie a thing 
    with radius 32 can fit into a 65-wide hallway). The maximum value this field *should* 
    have is 64.0 units. However, the game breaks its own rule here, giving several monsters 
    radii up to 128 units. These monsters, which include the Mancubus, Arachnotron, and Spider 
    Demon, exhibit clipping errors which enable other things to walk into them, and which can 
    cause some moving sectors to malfunction. Avoid giving things radii larger than 64.0 to 
    remain absolutely safe.
<li><b>height</b><br>
    Default = 16.0<br>
    Floating-point value that represents the height of this thing type. A thing can fit into 
    areas which are of this exact height or taller. Note that in DOOM, this value is only used 
    to see where a monster can fit relative to walls and floor/ceiling heights. For purposes of 
    clipping against other things, monsters were considered to be infinitely tall. However, 
    Eternity's extended 3D object clipping enables this field to also be used to allow or 
    disallow things to pass over, under, or stand on this thing.
<li><b>correct_height</b><br>
    Default = 0.0<br>
    Floating-point value that represents a height for this thing type which is corrected for
    3D object clipping. When 3D object clipping is enabled and the comp_theights variable is
    set to off, objects which have a non-zero correct_height field will begin to use this
    value for their height instead of the normal height field. If an object has the 3DDECORATION
    flags3 bit set, it will still clip missiles at its original height instead of at this value,
    so that playability of old maps is not altered. This field will generally only be necessary
    for old DOOM objects, which have now been assigned correct_height values in the default
    things.edf module. Use for new objects is discouraged; instead, set the <b>height</b> field
    above to the proper value. New to EDF 1.5.
<li><b>mass</b><br>
    Default = 100<br>
    Normal integer value that serves as a mass factor for this object. Mass affects the amount 
    of thrust an object is given when it is damaged, the amount of effect an archvile's attack 
    can have on it, and for bouncing objects, the rate at which they fall. Objects with a 
    mass less than 10 will cause small terrain hits when landing on terrain that supports
    small splashes.
<li><b>damage</b><br>
    Default = 0<br>
    This number is used as a damage multiplier when a missile hits a thing. 
    The damage formula used is: 
    <pre>
        damage = ((rnd % 8) + 1) * missiledamage
    </pre>
    
    This field is also used as a parameter by some new, parameterized codepointers, including 
    BetaSkullAttack and Detonate.
<li><b>activesound</b><br>
    Default = none<br>
    Sets the sound used by a thing when it is wandering around. A thing is given a 3 out of 
    256 chance (1.17%) of making this sound every time it calls the Chase codepointer. There 
    are some new flags3 flags which can alter the behavior of this sound.
<li><b>flags</b><br>
    Default = ""<br>
    This field controls a number of thing type properties using bit flags, where each bit in 
    the field stands for some effect, and has the value of being either on or off. 
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits">Bits Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>flags2</b><br>
    Default = ""<br>
    Similar to flags but takes a different set of values with different meanings. 
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits2">Bits2 Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>flags3</b><br>
    Default = ""<br>
    Similar to flags, but takes a different set of values with different meanings.
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits3">Bits3 Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>cflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field allows specification of all the thing's flag values in one
    single flag list. When this field is defined, the 3 normal flags fields above are ignored.
    You can use one or the other in any definition, but not both in the same definition. The
    only caveat to this field is that the <b>flags</b> bit "SLIDE", which has no effect, cannot 
    be specified in this field. If SLIDE is used, it will activate the flags3 bit with the same
    name, which has the expected effect. All other flags will be assigned to their appropriate
    internal fields as normal. See the DeHackEd documentation listed in the fields above for
    full information on flag list format and flag mnemonics.
<li><b>addflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field specifies a combined list of flags to be added to the thing's
    existing flags values (this works the same as the <b>cflags</b> field above). Flags in this
    list are "turned on" in the thing. If flags are listed here which are already "on," there
    is no effect on those flags. This field is most useful within <b>thingdelta</b> sections 
    and in concert with thing type inheritance.
<li><b>remflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field specifies a combined list of flags to be subtracted from the
    thing's existing flags values (this works the same as the <b>cflags</b> field above). Flags
    in this list are "turned off" in the thing, as if they had never been listed. If flags
    are listed here which are not already "on," there is no effect on those flags. This field 
    is most useful within <b>thingdelta</b> sections and in concert with thing type 
    inheritance. This field will be applied *AFTER* the addflags field is applied, so it 
    could potentially turn off flags turned on by that field.
<li><b>raisestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, an Archvile can perform a resurrection on this creature. When 
    this occurs, the creature will enter this frame.
<li><b>translucency</b><br>
    Default = 65536 (100%)<br>
    This field allows fine, customizable control over a thing's translucency. This field
    accepts two types of values. First, it may be given an integer value in the range of
    0 to 65536, with 0 being completely invisible, and 65536 being normal. Alternatively,
    beginning with EDF 1.3, you can provide a percentage value to this field indicating the
    amount of the foreground sprite that is blended with the background. A percentage value
    must be a base 10 integer between 0 and 100, with the final digit followed immediately
    by a '%' character (percent sign).
    <br><br>
    Note this effect is mutually exclusive of BOOM-style translucency. If this value is not 
    65536 (or 100%), and the BOOM translucency flag is turned on for the same thing type, the 
    flag will be turned off at run-time, and this field will take precedence.
<li><b>bloodcolor</b><br>
    Default = 0<br>
    Allows this thing type to have differently colored blood when particle blood effects are 
    enabled (this does not currently have any effect on blood sprites). Currently available 
    blood color values are as follows:
    <pre>
     Blood color       Number
    --------------------------
     Red (normal)        0
     Grey                1
     Green               2
     Blue                3
     Yellow              4
     Black               5
     Purple              6
     White               7
     Orange              8
    --------------------------
    </pre>
<li><b>fastspeed</b><br>
    Default = 0<br>
    When the game is switched into Nightmare difficulty or -fast mode is active, all thing
    types with a non-zero fastspeed will have their speed fields changed to their fastspeed
    value. This enables editing of the -fast speed of projectiles and monsters. For detailed
    information on speed, see the speed field itself above. Note: as of EDF 1.2, this field
    also supports floating-point numbers, with the same meaning as that for the speed field.
<li><b>nukespecial</b><br>
    Default = NULL<br>
    This field is the name of a special codepointer to call when the player uses the KILLEM
    cheat to kill all monsters. Currently only two special pointers are provided for this
    purpose, PainNukeSpec and SorcNukeSpec. These enable monsters with spawn-on-death actions
    to either spawn enemies early, or not at all. See the
    <a href="codeptrs.html">Eternity Engine Definitive Codepointer Reference</a>
    for detailed information.
<li><b>particlefx</b><br>
    Default = 0<br>
    This field is a flag field with syntax identical to the flags, flags2, and flags3 fields,
    but which accepts the following values which control what persistent particle effects are
    associated with objects of this type:
    <pre>
     Flag name       Hex Value     Effect
    --------------------------------------------------------
     ROCKET          0x00000001    Rocket trail
     GRENADE         0x00000002    Grenade trail
     FLIES           0x00000004    Swarm of flies w/ sound
     BFG             0x00000008    BFG particle swarm
     FLIESONDEATH    0x00000010    Flies when object dies
     DRIP            0x00000020    Parameterized drip effect
     REDFOUNTAIN     0x00010000    Red fountain
     GREENFOUNTAIN   0x00020000    Green fountain
     BLUEFOUNTAIN    0x00030000    Blue fountain
     YELLOWFOUNTAIN  0x00040000    Yellow fountain
     PURPLEFOUNTAIN  0x00050000    Purple fountain
     BLACKFOUNTAIN   0x00060000    Black fountain
     WHITEFOUNTAIN   0x00070000    White fountain
    --------------------------------------------------------
    </pre>
    Note that the fountain flag values cannot be combined with each other. Doing so will
    simply result in another one of the existing fountain colors.
    <br><br>
    The DRIP effect requires parameters to be specified in a thing's ExtraData
    <b>mapthing</b> block. The parameters to this effect are as follows:
    <ul>
    <li> args 0: color (palette index from 0 to 255)
    <li> args 1: particle width/height in pixels
    <li> args 2: frequency in gametics
    <li> args 3: if 1, particles cause terrain hits
    <li> args 4: if 1, particles are fullbright
    </ul>
    Examples:
    <pre>
    # a single effect
    particlefx = ROCKET
    
    # multiple effects
    particlefx = BFG|GREENFOUNTAIN
    
    # if there are spaces or disallowed characters, you must use quotations
    particlefx = "BFG + GREENFOUNTAIN"
    </pre>
<li><b>droptype</b><br>
    Default = NONE<br>
    This field allows the type of thing that is dropped by this thing when it dies to be
    edited. This field should either be a valid thing type mnemonic, or the special value
    NONE.
<li><b>mod</b><br>
    Default = UNKNOWN (0)<br>
    Special Means of Death flag for this thing type. Currently supported values follow below.
    The use of numbers in this field is now considered deprecated. Please use the descriptive
    textual MOD names in all new EDF projects.
    <pre>
    Mod Name    Number
    ------------------
    UNKNOWN       0
    FIST          1
    PISTOL        2
    SHOTGUN       3
    CHAINGUN      4
    ROCKET        5
    R_SPLASH      6
    PLASMA        7
    BFG           8
    BFG_SPLASH    9
    CHAINSAW      10
    SSHOTGUN      11
    SLIME         12
    LAVA          13
    CRUSH         14
    TELEFRAG      15
    FALLING       16
    SUICIDE       17
    BARREL        18
    SPLASH        19
    HIT           20
    BFG11K_SPLASH 21
    BETABFG       22
    BFGBURST      23
    PLAYERMISC    24
    GRENADE       25
    </pre>
    Specifying this field is not necessary for most thing types. It IS highly useful for controlling
    the obituaries triggered by player projectiles, however. Some of the values above are not
    fully supported yet. Eventually the LAVA type will cause fire death animations for things
    which define them.
<li><b>obituary_normal</b><br>
    Default = empty<br>
    Defines the obituary seen by players when killed by a projectile or other miscellaneous
    attack by a monster. If the obituary is not defined for this type, it will simply read that
    the player died. Note that you are only allowed to specify an obituary starting immediately
    after the player's name. If you want an obituary to say "Player was flamed",
    then simply make the obituary read "was flamed".
<li><b>obituary_melee</b><br>
    Default = empty<br>
    Defines the obituary seen by players when killed by a monster's melee attack.
    If the obituary is not defined for this type, it will simply read that the player died. Note 
    that you are only allowed to specify an obituary starting immediately after the player's 
    name. If you want an obituary to say "Player was stabbed mercilessly", then simply make the 
    obituary read "was stabbed mercilessly".
<li><b>translation</b><br>
    Default = 0<br>
    Sets a translation for the thing's sprite. Translation tables are 256-byte lumps which can
    be used to remap any range of colors in a sprite. When this field defaults, no translation
    will be used. Otherwise, you may either provide a number to access one of the internal
    player translation tables, or you may provide the name of a translation lump, which must
    be found between T_START and T_END markers amongst one of the currently loaded wad files.
    Numeric values for player translations are as follows. All of the player translations
    remap the pure green range.
    <pre>
    Number     Color
    ------------------
     1        Indigo
     2        Brown
     3        Red
     4        Tomato
     5        Dirt
     6        Blue
     7        Gold
     8        Felt
     9        Black
     10       Purple
     11       "Vomit"
     12       Pink
     13       Cream
     14       Yellow
    ------------------
    </pre>
<li><b>dmgspecial</b><br>
    Default = "none"<br>
    The dmgspecial field allows specification of a special action that will be taken when
    this object is involved in damaging another object as the inflictor (an inflictor is 
    the object actually doing the damage, and not necessarily the object that is blamed
    for the damage). Supported values and their meanings are as follows:
    <br><br>
    <ul>
    <li> none<br>
         This is the default value. No special action is taken; the object is normal when 
         damaging other things.
         <br><br>
    <li> MinotaurCharge<br>
         If the thing is flying like a skull (has flags bit SKULLFLY set), it will 
         inflict a large amount of thrust on the target along the vector of the impact, 
         will hit it directly for ((rnd % 8) + 1) * 6 damage, and if the target is a 
         player, the player's controls will be frozen for 14 + (rnd % 8) gametics.
         When the thing is not in SKULLFLY mode, normal damage is done by all attacks.
         <br><br>
    <li> Whirlwind<br>
         The target will have its angle and x/y momenta modified by random amounts. 
         If the current level time has the 5th bit (value 16) set and the target is not 
         a boss (possesses the BOSS flag), the target will be given randomized z momentum 
         up to but no greater than 12 units per tic. When the level time is divisible by 8, 
         the target will be hit directly for 3 damage.
    </ul>
    <br>
<li><b>skinsprite</b><br>
    Default = "noskin"<br>
    The skinsprite field defines a sprite that will be used to override the sprite value
    in any frame a thing of this type enters. This allows the creation of thingtypes which
    behave identically but look different without the creation of any new frames. Note that
    when things are crushed into gibs, the skinsprite is cleared at that time. If an Archvile
    resurrects such a thing, the proper skinsprite is then restored.
<li><b>dehackednum</b><br>
    Default = -1<br>
    As explained above, this is the number which must be used to refer to this thing type in
    DeHackEd patches. -1 means that the thing type is not accessible from DeHackEd, or by 
    parameterized codepointers that require a thing type DeHackEd number. User-defined thing
    types should currently only use DeHackEd numbers between 10000 and 32768, or simply use 
    -1 if no DeHackEd functionality is required. This number must be unique unless it is -1.
</ul>

Restrictions and Caveats:
<ul>
<li> At least two thing types must be defined (Unknown and DoomPlayer).
<li> The Unknown thing type must be defined.
<li> The DoomPlayer thing type must currently be defined (subject to change).
<li> All thing types must have a unique mnemonic no longer than 40 characters. They should only 
     contain alphanumeric characters and underscores. All other punctuation marks are explicity 
     reserved for extended syntactical use. Length will be verified, but format will not 
     (non-unique mnemonics will overwrite previous definitions, see below).
<li> All thing types with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     This will be verified.
</ul>

Replacing Existing Thing Types:
<br><br>
To replace the values of an existing thing type, simply define a new thing type with the exact 
same mnemonic value (as stated above, all thing types need a unique mnemonic, so duplicate 
mnemonics serve to indicate that an existing thing type should be replaced).
<br><br>
EDF 1.1 also adds delta structures, which allow fields of existing things to be edited
without replacing all values in those things. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# define a new thing type
thingtype ScarletPimpernel
{
  doomednum = 15000
  spawnstate = S_SCARPIMP1
  flags = SPECIAL|NOTDMATCH
  dehackednum = 10000
}

# overwrite an existing thing type (assume BaronOfHell is already defined normally...)
# everything is the same as the original except the fields I changed...
thingtype BaronOfHell
{
  doomednum = 3003
  spawnstate = S_BOSS_STND
  seestate = S_BOSS_RUN1
  seesound = brssit
  painstate = S_BOSS_PAIN
  painchance = 10                  # changed from 50 to 10
  painsound = dmpain
  meleestate = S_BOSS_ATK1
  missilestate = S_BOSS_ATK1
  deathstate = S_BOSS_DIE1
  deathsound = brsdth
  speed = 12                       # changed to from 8 to 12
  radius = 24.0000
  height = 64.0000
  mass = 1000
  activesound = dmact
  flags = SOLID|SHOOTABLE|COUNTKILL
  flags2 = E1M8BOSS|FOOTCLIP
  raisestate = S_BOSS_RAISE1
  obituary_normal = "was burned by a baron"
  obituary_melee  = "was ripped open by a baron"
  dehackednum = 16
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inherit">
<hr>
<b>Thing Type Inheritance</b>
<hr>
</a>
<br>
New to EDF 1.2, thing type inheritance allows you to derive new thing types from existing
ones, so that there is no need to duplicate all the fields in the original type. To activate
inheritance for a thing type, use the following syntax:
<pre>
thingtype &lt;unique mnemonic&gt;
{
   inherits = &lt;thing type mnemonic&gt;
   &lt;any other thingtype fields&gt;
}
</pre>

When the <b>inherits</b> field is set in a thing type, its parent type will be processed first
if it has not already been processed. Then, all the fields from the parent type, except for
<b>dehackednum</b> and <b>doomednum</b>, will be copied from the parent type to this type. Once 
the parent is copied, any other fields in this type will be treated as a <b>thingdelta</b> section, 
such that only fields explicitly provided will overwrite values from the parent thing type.  
Defaults will not be applied for unlisted fields, again with the exceptions of <b>dehackednum</b>
and <b>doomednum</b>.
<br><br>
Thing delta sections are applied to thing types after initial processing is finished, and thus
do not affect the inheritance process. If a thing delta section is applied to a parent type, it
will not affect the child type.  Thing deltas applied to child types apply after both inheritance
and any values overridden in the child type.
<br><br>
Restrictions and Caveats:
<ul>
<li> A thing type may not inherit from itself, or from other thing types in a cycle. Circular
     inheritance errors will be caught by the processor and an error will occur, although
     possibly not during processing of the first inheriting type (the error may be found while
     processing a parent type).
<li> Only one thing type may be inherited from by each thing type, so there is no concept of
     multiple inheritance. However, there is no limit to the number of levels of inheritance
     other than the number of existing thing types, so each parent thing type may have its
     own parent, excepting the ultimate parent in an inheritance tree.
</ul>

Inheritance Example:
<pre>
/*
   As you can see here, thing type inheritance allows inheriting type 
   definitions to be minimized to only those fields which must differ. 
   In this example, the dehackednum of the new thing type will be -1, 
   since it is unspecified. The doomednum will be 20001, since it is 
   not inherited, but is specified in the child type. Remember that the 
   dehackednum and doomednum fields are NOT copied between thing types.
*/

thingtype MyNewBaron
{
   inherits     = BaronOfHell   # Inherit from the BaronOfHell
   doomednum    = 20001         # Set the doomednum to something meaningful
   translucency = 50%           # Make it 50% translucent
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="cast">
<hr>
<b>DOOM II Cast Call</b>
<hr>
</a>
<br>
The cast call structure allows you to edit and extend the DOOM II cast call used after
beating the game in DOOM II. Editing existing thing types via EDF or DeHackEd can otherwise
cause this part of the game to malfunction, and it has never before been possible to add your
own monsters into the fray. Now this can be done.
<br><br>
Unlike most other EDF sections, <b>castinfo</b> sections will be kept in the order they are 
specified, unless the <b>castorder</b> array is defined. The <b>castorder</b> array feature 
allows you to explicitly specify a complete ordering for the <b>castinfo</b> sections which 
overrides the order of their definitions. See below for more information on <b>castorder</b>.
<br><br>
Beginning with EDF 1.1, all <b>castinfo</b> sections are required to have a unique mnemonic. 
Sections with duplicate mnemonics will overwrite, with the last one occuring during parsing 
taking precedence as the definition.
<br><br>
Syntax:
<pre>
castinfo &lt;mnemonic&gt;
{
   type       = &lt;thing type mnemonic&gt;
   name       = &lt;string&gt;
   stopattack = &lt;boolean&gt;
   
   # see notes about this; there can be from zero to four sound blocks
   sound
   { 
      frame = &lt;frame mnemonic&gt;
      sfx   = &lt;sound mnemonic&gt;
   }
}
</pre>

Explanation of Fields:
<ul>
<li><b>type</b><br>
    Default = No default; this field is required.<br>
    This field must be set to a valid thing type mnemonic. This denotes which thing type is
    displayed at this entry's position in the cast call. As of EDF 1.2, if this type is not
    valid, the thing type "Unknown" will be substituted. This may cause the cast call to
    malfunction, however. The previous behavior was to cause an error.
<li><b>name</b><br>
    Default = See below.<br>
    This is an optional field that allows providing a name to display on the screen for the
    thing type. Note that if this field is not present in any of the first 17 definitions, 
    those cast members will use the normal default names from the executable, which are
    editable via BEX string replacement. If cast members beyond the first 17 have no name
    provided, they will say "unknown" (so you should always provide it in those cases).
<li><b>stopattack</b><br>
    Default = false<br>
    This is a special boolean value (can be any of yes/no, on/off, or true/false) which makes
    the thing break out of its attack frame cycle after its initial frame. This is only used
    by the player type by default, but could be used by any other type as well.
<li><b>sound</b><br>
    There can be up to four of these special blocks defined within each cast member. They
    define a sound event, so that whenever the thing type enters the designated frame, it will
    play the designated sound. If there are less than four definitions, the unused ones will
    be zeroed out. If there are more than four, any beyond four are simply ignored. Also, if
    the values provided to the fields in this block are invalid, they are simply ignored.<br>
    Explanation of Inner Fields:
    <ul>
    <li><b>frame</b><br>
        Default = S_NULL<br>
        Name of the frame this event should occur on
    <li><b>sfx</b><br>
        Default = none<br>
        Name of the sound to play when this event occurs.
    </ul>
</ul>

Restrictions and Caveats:
<ul>
<li> The castorder list is NOT required.
<li> At least one cast member must be defined.
<li> All cast members must have a unique mnemonic. Mnemonics should only contain alphanumeric 
     characters and underscores. All other punctuation marks are explicity reserved for 
     extended syntactical use. Format will not be verified. Non-unique mnemonics will overwrite 
     previous definitions, see below.
</ul>

Full Example:
<pre>
# My New Cast Call -- Only The Ultimate FooBar and the Player are worthy!
castinfo foobar
{
   type = FooBar
   name = "The Ultimate FooBar"
   
   sound { frame = S_FOOBAR_ATK1; sfx = firsht }
   sound { frame = S_FOOBAR_ATK3; sfx = firsht }
   sound { frame = S_FOOBAR_ATK5; sfx = firsht }
}

# Notice since DoomPlayer is now #2 and not #17, I still need to set his
# name, otherwise it would call him a former sergeant o_O
castinfo player
{
   type = DoomPlayer
   name = "Our Hero"
   stopattack = true
}
</pre>

Using the <b>castorder</b> Array
<br><br>
When editing the cast call, it will probably be advantageous to specify the <b>castorder</b> 
array. Doing so will allow you to avoid the EDF 1.0 problem of being forced to redefine the 
entire cast call simply to add a new cast member in the middle. It also allows you to move 
around existing <b>castinfo</b> definitions without editing them, and to omit or repeat
definitions.
<br><br>
Syntax:
<pre>
castorder = { &lt;mnemonic&gt;, ... }
</pre>

All mnemonics specified in the <b>castorder</b> list must be valid. If any do not exist, 
an error will occur.
<br><br>
As with other EDF lists, if the list is defined more than once, the latest definition
encountered is the one used. Also, you may use addition lists to add entries to the end of
the <b>castorder</b> list.
<br><br>
Full Example:
<pre>
# I decided to switch the cast call order around
castorder = { player, foobar }

...

# Later on, perhaps in another file, I add a new castinfo. I can do this:
castinfo weirdo
{
   type = WeirdoGuy
   name = "The Weirdo Guy"
}

# This will add weirdo to the end of the existing castorder list.
# I could also just redefine the entire list, but there's no point in this case.
castorder += { weirdo }
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="boss">
<hr>
<b>DOOM II Boss Brain Types</b>
<hr>
</a>
<br>
The Boss Brain thing types list allows editing of the types of monsters which can be spawned
by the DOOM II Boss Brain cube spitter object. This structure is a simple list of thing
type mnemonics, which are kept in the order they are provided. You can redefine the list at will, 
just as with the <b>spritenames</b> list.
<br><br>
Starting with EDF 1.1, there is no longer an 11-type limitation on the boss spawner list.
However, if you provide more than 11 thing types in this list, you must also define the new
<b>boss_spawner_probs</b> list, which must be a list of numbers which when added together 
equal 256. These numbers serve as the probability values out of 256 for the corresponding 
thing types. If exactly 11 types are defined and the <b>boss_spawner_probs</b> list is not 
defined, the normal defaults will be used. If boss_spawner_probs is defined, it MUST be the
exact same length as the boss_spawner_types list.
<br><br>
Starting with EDF 1.2, if a thing type in the <b>boss_spawner_types</b> list is invalid, the
"Unknown" thing type will be substituted for it. The previous behavior was to cause an error.
<br><br>
Syntax:
<pre>
# A list of thing types

boss_spawner_types =
{
   &lt;thing type mnemonic&gt;, ...
}

# A list of probabilities for the above thing types. If provided, this list
# must be the same length as the above, and if not provided, the above list
# must contain exactly 11 types. The numbers in this list must add up to 256.

boss_spawner_probs =
{
   &lt;number&gt;, ...  
}
</pre>

Full Example:
<pre>
# Changed DoomImp to FooBar, and Archvile to the ScarletPimpernel
# (so it can give you a powerup, but not very often, since Archvile is the
#  rarest type ;)
# In a TC you might want to change ALL the monster types...
# These will use the default probabilities listed below, unless a
# boss_spawner_probs list is also defined somewhere.

boss_spawner_types =
{
   FooBar, Demon, Spectre, PainElemental, Cacodemon, ScarletPimpernel,
   Revenant, Arachnotron, Mancubus, HellKnight, BaronOfHell
}
</pre>

Example with More than 11 Thing Types:
<pre>
boss_spawner_types =
{
   DoomImp, Demon, Spectre, PainElemental, Cacodemon, Archvile, Revenant,
   Arachnotron, Mancubus, HellKnight, BaronOfHell, FooBar, ScarletPimpernel
}

boss_spawner_probs =
{
   40, 40, 30, 10, 30, 2, 10, 20, 30, 22, 10, 10, 2
}
</pre>

Normal Default Probabilities Used When 11 Types are Defined:
<pre>
boss_spawner_probs =
{
# prob. / thing type normally in this position in the list
   50,  # DoomImp
   40,  # Demon
   30,  # Spectre
   10,  # PainElemental
   30,  # Cacodemon
    2,  # Archvile
   10,  # Revenant
   20,  # Arachnotron
   30,  # Mancubus
   24,  # HellKnight
   10   # BaronOfHell
}
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="sound">
<hr>
<b>Sounds</b>
<hr>
</a>
<br>
New to EDF 1.1, sound definitions allow editing of existing sounds, as well as the addition of 
new sounds which can be referred to by things and frames. Although Eternity already supports the 
implicit addition of new sounds whose lumps start with the DS prefix, those sounds are only 
available to MapInfo and scripting. Since EDF allows the assignment of DeHackEd numbers, it 
allows much greater flexibility for new sounds.
<br><br>
EDF also provides access to some sound structure fields which are not currently supported
in DeHackEd.
<br><br>
Each sound must be given a unique mnemonic in its definition's header, and this is the name
used to identify the sound elsewhere. Each field in the sound definition is optional. If a 
field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
Syntax:
<pre>
sound &lt;mnemonic&gt;
{
   lump          = &lt;string&gt;
   prefix        = &lt;boolean&gt;
   singularity   = &lt;singularity class&gt;
   priority      = &lt;number&gt;
   link          = &lt;sound mnemonic&gt;
   linkvol       = &lt;number&gt;
   linkpitch     = &lt;number&gt;
   skinindex     = &lt;skin index type&gt;
   clipping_dist = &lt;number&gt;
   close_dist    = &lt;number&gt;
   dehackednum   = &lt;number&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>lump</b><br>
    Default: If not provided, the mnemonic will be copied directly to the lump name. For example,
    if the mnemonic for an entry is dsfoo and the lump name is not provided, it will become
    dsfoo, and in that case, the prefix field (explained below) should be set to false.<br>
    The lump field indicates the lump name that this sound resource will have in WAD files.
    If the prefix field below is true, the prefix "DS" will be appended to this name when looking
    for the sound. Otherwise, this name will be used exactly as it is provided. In the event a
    sound is not found, a default sound for the current game mode (DSPISTOL in DOOM, GLDHIT in
    Heretic) will be played instead.
<li><b>prefix</b><br>
    Default = true<br>
    This boolean field indicates whether to prefix the lump name with DS when searching for
    this sound's lump. Values of false/no/off mean that the lump will not be prefixed. Values
    of true/yes/on mean that it should be prefixed. 
<li><b>singularity</b><br>
    Default = sg_none<br>
    This field indicates a singularity class for this sound. If another sound of the same
    singularity class is playing when this sound is played, the former will be stopped. This is
    used to implement appropriate player sound behavior in an extensible and modifiable manner.
    The possible values for the singularity class are as follows:
    <pre>
    sg_none
    sg_itemup
    sg_wpnup
    sg_oof
    sg_getpow</pre>
<li><b>priority</b><br>
    Default = 64<br>
    This field establishes a relative priority for this sound. When sounds must be stopped in
    order to start new ones, those with the lowest priority will be replaced first.
<li><b>link</b><br>
    Default = "none"<br>
    This field links this sound definition to another existing sound definition. Its value must
    either be "none," or another valid sound mnemonic. When a linked sound is played, the sound
    that is linked to will be played instead, using the linkvol and linkpitch parameters provided
    in this sound entry. Use of this feature will rarely be necessary and is not recommended.
<li><b>linkvol</b><br>
    Default = -1<br>
    This field provides a value to be added to the sound's volume when a linked sound is played
    through this sound definition.
<li><b>linkpitch</b><br>
    Default = -1<br>
    This field provides a pitch value to be used when a linked sound is played through this
    sound definition.
<li><b>clipping_dist</b><br>
    Default = 1200<br>
    This value specifies the distance from the origin at which this sound will be completely
    clipped out; that is, reduced to zero volume and therefore killed completely. The sound
    engine currently only considers an approximate distance on the X-Y plane, so this behavior
    may be slightly more rough than expected. The value of this field should be greater than 
    the value of the <b>close_dist</b> field below. If not, the sound will always be played
    at full volume (this can be intentionally exploited). New to EDF 1.5.
<li><b>close_dist</b><br>
    Default = 200<br>
    This value specifies the distance from the origin at which this sound will be at full
    volume. Attenuation between the <b>clipping_dist</b> and <b>close_dist</b> values is 
    currently always linear. The sound engine currently only considers an approximate distance
    on the X-Y plane, so this behavior may be slightly more rough than expected. The value of
    this field should be less than the value of the <b>clipping_dist</b> field above. If not,
    the sound will always be played at full volume (this can be intentionally exploited).
    New to EDF 1.5.    
<li><b>skinindex</b><br>
    Default = sk_none<br>
    This field indicates a player skin sound index for this sound. If the player object plays
    this sound, it will become subject to remapping through the player's skin. The following
    values are possible for skin index, and each corresponds to one of the fields in the
    extended Legacy skin format:  <!-- TODO: add link to new skin format documentation! -->
    <pre>
    sk_none
    sk_plpain
    sk_pdiehi
    sk_oof
    sk_slop
    sk_punch
    sk_radio
    sk_pldeth
    sk_plfall
    sk_plfeet
    sk_fallht</pre>    
<li><b>dehackednum</b><br>
    Default = -1<br>
    In order to be accessible to thing and frame definitions, a sound definition must be given
    a unique DeHackEd number. The value zero is reserved and cannot be used. In order to avoid
    conflict, and to remain compatible with future versions of the Eternity Engine, user sounds
    should either use DeHackEd numbers between 10000 and 32768, or simply use the value -1 if
    no thing/frame or DeHackEd access is necessary. Note that if a thing or frame later attempts
    to use a sound with no unique DeHackEd number via its mnemonic, a warning will be printed
    to the verbose EDF log, and the sound field in question will be set to "none".
</ul>

Restrictions and Caveats:
<ul>
<li> All sounds must have a unique mnemonic no longer than 16 characters. They should only 
     contain alphanumeric characters and underscores. Length will be verified, but format will 
     not (non-unique mnemonics will overwrite previous definitions, see below). The mnemonic
     "none" is reserved and cannot be overridden or edited. Sounds using the mnemonic "none"
     will not be playable.
<li> If the lump name is not provided, so that the mnemonic will be copied to it, then the
     mnemonic must also either be a full, valid lump name, or a string that becomes one if
     the prefix field is set to true. If a mnemonic is used which is not a valid sound lump
     name, but no lump name is provided, then the sound entry will not be able to play, and
     the default replacement sound for the game mode will play instead.
<li> All sounds with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     Any sounds with a non-unique DeHackEd number will be inaccessible to things, frames, and
     editing via DeHackEd. Such sounds may still be referenced via their mnemonic in scripts
     and MapInfo, however. The DeHackEd number 0 (zero) is reserved for sounds and cannot be
     used in an EDF sound definition.
</ul>

Replacing Existing Sounds:
<br><br>
To replace the values of an existing EDF sound definition, simply define a new sound 
with the exact same mnemonic value (as stated above, all sounds need a unique mnemonic, so 
duplicate mnemonics serve to indicate that an existing sound should be replaced).
<br><br>
EDF 1.1 adds delta structures, which allow fields of existing sounds to be edited
without replacing all values in those sounds. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# Define some new sounds
# This one is only accessible via scripting because it doesn't have a DeHackEd number.
sound MySound
{
   lump = foo  # this will play DSFOO, since prefix defaults to true
}

# This entry uses its mnemonic to double as the sound lump name.
sound dsblah
{
   prefix = false  # Without this, it would try to play DSDSBLAH, which is wrong
   dehackednum = 10000
}

# This entry also uses the mnemonic as the sound name, but with prefixing.
# Since prefix defaults to true, the sound lump played will be "DSEXPLOD".
sound explod
{
   priority = 128
   dehackednum = 10001
}

# This entry links to another sound.
sound BlahLink
{
   lump = dummy    # this won't even get used in this case
   prefix = false  # dsblah doesn't need a prefix, so we should echo that here
   link = dsblah   # we've linked this entry to the dsblah sound
   linkvol = 150   # use some suitable values for these (must experiment)
   linkpitch = 0
   dehackednum = 10002
}

# This entry overrides a previously defined sound.
sound explod
{
   priority = 96        # Maybe we like 96 better than 128...
   dehackednum = 10001  # We can reuse the same DeHackEd number, since it overwrites
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="terrain">
<hr>
<b>TerrainTypes</b>
<hr>
</a>
<br>
As of EDF 1.5, the TerrainTypes system has been completely absorbed into EDF. This means it
is now possible to completely customize not only what flats are associated with what terrain
effects, but the effects themselves. There are three principle object types associated with
the TerrainTypes system -- splashes, terrains, and floors. Each will be discussed in its own
subsection below.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="splashes">
<hr>
<b>Splash Objects</b>
<hr>
</a>
<br>
Splash objects define the thingtypes, sounds, and other properties of a splash caused by an
thing hitting a terrain. Not all terrains must have splashes, and each terrain can only refer
to one splash object. A splash object itself defines properties for both a low mass and high
mass splash, however. All fields in the splash block are optional, and as usual, order is 
irrelevant.
<br><br>
All splash blocks must have a unique mnemonic. Non-unique mnemonics will overwrite, meaning
that the properties of the last splash block encountered with a given name will become the
final properties of that splash object.
<br><br>
Syntax:
<pre>
splash &lt;unique mnemonic&gt;
{
   smallclass = &lt;thingtype mnemonic&gt;
   smallclip  = &lt;number&gt;
   smallsound = &lt;sound mnemonic&gt;
   baseclass  = &lt;thingtype mnemonic&gt;
   chunkclass = &lt;thingtype mnemonic&gt;
   sound      = &lt;sound mnemonic&gt;
   
   chunkxvelshift = &lt;number&gt;
   chunkyvelshift = &lt;number&gt;
   chunkzvelshift = &lt;number&gt;
   chunkbasezvel  = &lt;number&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>smallclass</b><br>
    Default = No object will be spawned<br>
    This field specifies the thingtype spawned by a low mass splash (objects of mass less than
    10 cause low mass splashes if possible). If this field is unspecified or is an invalid
    thing type, low mass splash objects will not spawn for any terrain that uses this splash
    object.
<li><b>smallclip</b><br>
    Default = 0<br>
    This field specifies an amount of floorclip in units to add to the low mass splash object.
    This allows use of objects that would otherwise look incorrect for low mass splashes by 
    making them appear smaller. A typical value for this field is 12 units.
<li><b>smallsound</b><br>
    Default = "none"<br>
    The sound specified in this field will be played by mnemonic whenever a low mass splash
    occurs, independent of whether a valid <b>smallclass</b> is defined. This means you should
    always define the smallsound field if sounds are desired, even if its value is the same as 
    the <b>sound</b> field. Otherwise, no sound will be played for low mass splashes.
<li><b>baseclass</b><br>
    Default = No object will be spawned<br>
    This field specifies the thingtype spawned as the base of a normal splash. If this field
    is unspecified or is an invalid thing type, no splash base will be spawned for any
    terrain that uses this splash object.
<li><b>chunkclass</b><br>
    Default = No object will be spawned<br>
    This field specifies the thingtype spawned as a chunk thrown upward from the point of a
    normal splash. The velocities given to this object when spawned are randomized and are
    customized via the chunk?velshift and chunkbasezvel fields below. If this field is
    unspecified or is an invalid thing type, no splash chunk will be spawned for any terrain
    that uses this splash object.
<li><b>sound</b><br>
    Default = "none"<br>
    The sound specified in this field will be played by mnemonic whenever a normal splash
    occurs, independent of whether a valid <b>baseclass</b> or <b>chunkclass</b> is defined.
<li><b>chunkxvelshift</b><br>
    Default = -1<br>
    When set to a positive value, this field indicates a value 2^N by which to multiply
    a randomized number used as the x axis velocity of the splash chunk object. When set to
    -1, the splash chunk will be given no x velocity.
<li><b>chunkyvelshift</b><br>
    Default = -1<br>
    When set to a positive value, this field indicates a value 2^N by which to multiply a
    randomized number used as the y axis velocity of the splash chunk object. When set to
    -1, the splash chunk will be given no y velocity.
<li><b>chunkzvelshift</b><br>
    Default = -1<br>
    When set to a positive value, this field indicates a value 2^N by which to multiply a
    randomized number which is added to the <b>chunkbasezvel</b>, the sum of which becomes the
    z velocity of the splash chunk object. When set to -1, no randomized addend will be used.
<li><b>chunkbasezvel</b><br>
    Default = 0<br>
    When set to a positive value, this field indicates a base amount of z velocity to apply
    to the splash chunk object. The randomized value determined by chunkzvelshift is then
    added to this base amount of velocity. If set to zero while the chunkzvelshift value is
    set to -1, the splash chunk object will be given no z velocity.
</ul>

Restrictions and Caveats:
<ul>
<li> All splashes must have a unique mnemonic no longer than 32 characters. They should only 
     contain alphanumeric characters and underscores. Length will be verified, but format will 
     not (non-unique mnemonics will overwrite previous definitions).
</ul>

Replacing Existing Splashes:
<br><br>
To replace the values of an existing EDF splash definition, simply define a new splash 
with the exact same mnemonic value (as stated above, all splashes need a unique mnemonic, so 
duplicate mnemonics serve to indicate that an existing splash should be replaced).
<br><br>
Full Example:
<pre>
// The Water splash object as defined in terrain.edf demonstrates a 
// fully-defined splash object:

splash Water
{
   smallclass = EETerrainWaterBase
   smallclip  = 12
   smallsound = eedrip
   
   baseclass  = EETerrainWaterBase
   chunkclass = EETerrainWaterSplash
   sound      = gloop   
   
   chunkxvelshift = 8
   chunkyvelshift = 8
   chunkzvelshift = 8
   chunkbasezvel  = 2
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="terrain">
<hr>
<b>Terrain Objects</b>
<hr>
</a>
<br>
Terrain objects define the full properties of a TerrainType which can be assigned directly to
multiple flats. Terrains may optionally define what splash object they use, as well as values
related to inflicting damage, whether or not the terrain is liquid, whether or not hitting 
the terrain causes enemies to awaken, and other important information. All fields in the 
splash block are optional, and as usual, order is irrelevant.
<br><br>
All terrain blocks must have a unique mnemonic. Non-unique mnemonics will overwrite, meaning
that the properties of the last terrain block encountered with a given name will become the
final properties of that terrain object.
<br><br>
Terrain deltas are also supported for editing the properties of existing terrain objects
without duplicating all fields within them.  See the <a href="#delta">Delta Structures</a>
section for full information.
<br><br>
Syntax:
<pre>
terrain &lt;unique mnemonic&gt;
{
   splash         = &lt;splash mnemonic&gt;
   damageamount   = &lt;number&gt;
   damagetype     = &lt;MOD name&gt;
   damagetimemask = &lt;number&gt;
   footclip       = &lt;number&gt;
   liquid         = &lt;boolean&gt;
   splashalert    = &lt;boolean&gt;
   useptclcolors  = &lt;boolean&gt;
   ptclcolor1     = &lt;palette index&gt; OR &lt;RGB triplet&gt;
   ptclcolor2     = &lt;palette index&gt; OR &lt;RGB triplet&gt;
   minversion     = &lt;number&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>splash</b><br>
    Default = No splash is used by this terrain<br>
    This field specifies what splash object, if any, to use when objects strike a floor using
    a flat that is associated with this terrain object.
<li><b>damageamount</b><br>
    Default = 0<br>
    This field specifies the amount of damage this terrain inflicts on players at each
    damage opportunity (determined by the damagetimemask field below). If this field is zero,
    no damage will be inflicted.
<li><b>damagetype</b><br>
    Default = "UNKNOWN"<br>
    Defines the Means of Damage flag used when this terrain damages a player. Values of
    interest to terrain are typically SLIME and LAVA. Eventually, LAVA will cause thing types
    which define a special flaming death frame to enter that frame. Please keep this in mind
    for forward compatbility. Other values for the Means of Death flag can be found in the
    <a href="#things">thingtype</a> section.
<li><b>damagetimemask</b><br>
    Default = 0<br>
    Sets the interval at which this terrain will inflict damage on players. This value is
    applied as a mask to the current level time, so to be most meaningful, this value must
    be a power of two minus one. A few valid values are 1, 3, 7, 15, and 31. Most DOOM 
    nukage sectors use a mask of 31 as an example, and thus damage the player every 32 gametics,
    or approximately once per second.
<li><b>footclip</b><br>
    Default = 0<br>
    This value defines the amount of footclip in units that this terrain applies to objects
    standing on it that have the flags2 bit FOOTCLIP set in their options. A footclip of zero
    means no footclipping is applied. Some special objects may set their own footclip values
    and thus may not be affected by terrain footclipping in any case. Footclipping is generally
    only proper for liquid terrain.
<li><b>liquid</b><br>
    Default = false<br>
    Specifies whether or not this terrain is liquid. Currently the only effect controlled
    by this field is suppressing player "oof" sounds when landing on liquid terrains, under
    the assumption that a splash sound will playing instead. In the future, certain special
    Heretic objects will react specially to liquid terrain.
<li><b>splashalert</b><br>
    Default = false<br>
    Specifies whether or not this terrain causes a noise alert to propagate when a player hits
    a floor using this terrain. Setting this field to true means that a player hitting the
    given floors will cause enemies to awaken and begin chasing him. By default, DOOM terrain
    types do not do this, and Heretic terrain types do.
<li><b>useptclcolors</b><br>
    Default = false<br>
    When set to true, this terrain object wants to use customized particle colors when
    gunshots and certain other effects strike the floor or ceiling of a sector using a flat
    with which this terrain is associated. Terrains which set this value to false will have
    their <b>ptclcolor1</b> and <b>ptclcolor2</b> fields ignored and will use the default
    gray bullet puff effects.
<li><b>ptclcolor1</b><br>
    Default = 0<br>
    This field may specify either a raw palette index from 0 to 255, or an RGB triplet string
    in the format "r g b", with each of r, g, and b being a number from 0 to 255. When an RGB
    triplet is specified, EDF will attempt to match the specified color to the closest color
    in the game's main palette. If no suitable match can be found, color zero will end up 
    being chosen. For terrain effects that must work across multiple games, you should always
    utilize RGB triplets. Otherwise, palette indices are more accurate. This value is ignored
    if <b>useptclcolors</b> is false for this terrain object. This color is typically the
    darker of the two particle colors used for terrain effects.
<li><b>ptclcolor2</b><br>
    Default = 0<br>
    This field may specify either a raw palette index from 0 to 255, or an RGB triplet string
    in the format "r g b", with each of r, g, and b being a number from 0 to 255. When an RGB
    triplet is specified, EDF will attempt to match the specified color to the closest color
    in the game's main palette. If no suitable match can be found, color zero will end up 
    being chosen. For terrain effects that must work across multiple games, you should always
    utilize RGB triplets. Otherwise, palette indices are more accurate. This value is ignored
    if <b>useptclcolors</b> is false for this terrain object. This color is typically the
    lighter of the two particle colors used for terrain effects.
<li><b>minversion</b><br>
    Default = 0<br>
    This field controls the minimum demo version in which this terrain object is usable.
    This field is unnecessary for the majority of user-created terrain objects, and this value
    should not be edited in the default terrain objects, neither via overriding nor terraindeltas,
    if your project is meant to function in the presence of old demos. minversion for the
    default objects is the first Eternity Engine version in which that terrain appeared.
</ul>

Restrictions and Caveats:
<ul>
<li> All terrains must have a unique mnemonic no longer than 32 characters. They should only 
     contain alphanumeric characters and underscores. Length will be verified, but format will 
     not (non-unique mnemonics will overwrite previous definitions).
<li> The default terrain called "Solid" is defined internally by the game engine, but can be
     edited by creating a terrain named "Solid" in EDF. This should be done with caution,
     however, since the default terrain is used in all circumstances when no terrain effects
     are usually expected. The Solid terrain has default values for all fields.
</ul>

Replacing Existing Terrains:
<br><br>
To replace the values of an existing EDF terrain definition, simply define a new terrain
with the exact same mnemonic value (as stated above, all terrains need a unique mnemonic, so 
duplicate mnemonics serve to indicate that an existing terrain should be replaced).
<br><br>
Full Example:
<pre>
// The Water terrain object as defined in terrain.edf demonstrates a 
// typical terrain object:

terrain Water
{
   splash   = Water
   footclip = 10
   liquid   = true
   
   useptclcolors = true
   ptclcolor1    = "127 127 255"
   ptclcolor2    = "0 0 255"
   
   minversion = 329
}

// This terrain defines damage properties only to create an 
// instant-death floor type:

terrain SuperDeadly
{
   damageamount   = 10000  // inflict telefrag damage
   damagetype     = LAVA   // use LAVA MOD
   damagetimemask = 1      // inflict damage more or less constantly
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="floors">
<hr>
<b>Floor Objects</b>
<hr>
</a>
<br>
Floor objects associate a terrain with a flat graphic. All fields in the floor block are 
optional, and as usual, order is irrelevant. Floor objects are precisely equivalent to entries
in the old, obsolete binary TERTYPES lump, and in fact, TERTYPES is still supported for legacy
projects, and will be used to generate additional floor objects if it is found. See the
<a href="#tertypes">TERTYPES Lump Processing</a> section below for more information.
<br><br>
Multiple floor objects may associate the same flat with different terrains. The last such
definition encountered will determine what terrain the flat uses.
<br><br>
Syntax:
<pre>
floor
{
   flat    = &lt;string&gt;
   terrain = &lt;terrain mnemonic&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>flat</b><br>
    Default = "none"<br>
    This field determines the flat to which this floor object's terrain is applied. If a
    terrain has already been applied to this flat, the terrain specified in this object will
    override the previous definition. This field need not refer to a valid flat name. No
    error will occur if the flat specified does not exist; this object will simply have no
    effect. However, the string specified in this field must be no longer than eight characters
    or an error will occur.
<li><b>terrain</b><br>
    Default = Solid<br>
    This field specifies the mnemonic of the terrain to associate with the flat named in this
    floor object. As mentioned in the terrain section above, the default Solid terrain type is
    defined by the game engine. By default, all floors are associated with the Solid terrain.
    The terrain mnemonic need not be a valid terrain. If it is invalid, a warning will be
    issued to the verbose EDF log file and the floor object will be modified to use the Solid
    terrain object.
</ul>

Full Example:
<pre>
// A couple of the floor objects defined for DOOM in terrain.edf:
floor { flat = FWATER1; terrain = Water }
floor { flat = LAVA1;   terrain = Lava  }
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="tertypes">
<hr>
<b>TERTYPES Lump Processing</b>
<hr>
</a>
<br>
The old binary TERTYPES lump is now considered obsolete, and thus its format is not
described here, nor is any way to generate one any longer available from Team Eternity.
However, to support legacy projects, Eternity will translate the last TERTYPES lump loaded
into EDF floor definitions dynamically, using the following assumptions:
<ul>
<li> TERTYPES floor definitions associated with the value zero are mapped to the default
     Solid terrain.
<li> TERTYPES floor definitions associated with the value 1 are mapped to the terrain named
     "Water". If no Water terrain exists, the floor will be mapped to the Solid type.
<li> TERTYPES floor definitions associated with the value 2 are mapped to the terrain named
     "Lava". If no Lava terrain exists, the floor will be mapped to the Solid type.
<li> TERTYPES floor definitions associated with the value 3 are mapped to the terrain named
     "Sludge". If no Sludge terrain exists, the floor will be mapped to the Solid type.
</ul>
This results in behavior identical to that under the old static TerrainTypes system, if and
only if the default terrain objects or objects with equivalent names and behaviors are 
available for use. TERTYPES lump processing is done after EDF floor objects are processed, and
thus any TERTYPES-derived definitions may override EDF floor objects that affect the same
flats.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="delta">
<hr>
<b>Delta Structures</b>
<hr>
</a>
<br>
New to EDF 1.1, delta structures are an easier and more flexible way to edit existing thing 
type, frame, sound, and terrain definitions.
<br><br>
Each delta structure for a thing type, frame, sound, or terrain specifies by mnemonic the 
section that it edits inside it. This allows for any number of delta structures to be defined.
The structures are always applied in the order in which they are encountered during parsing, 
so that, like style sheets in HTML, delta structures cascade. This means you can load your
own set of delta structures on top of an existing set in a modification.
<br><br>
Delta Structure Syntax:
<pre>
# A delta structure for a frame has this syntax:
framedelta
{
   name = &lt;frame mnemonic&gt;
   &lt;list of frame fields&gt;
}

# A delta structure for a thing type has this syntax:
thingdelta
{
   name = &lt;thingtype mnemonic&gt;
   &lt;list of thingtype fields&gt;
}

# A delta structure for a sound has this syntax:
sounddelta
{
   name = &lt;sound mnemonic&gt;
   &lt;list of sound fields&gt;
}

# A delta structure for a terrain has this syntax:
terraindelta
{
   name = &lt;terrain mnemonic&gt;
   &lt;list of terrain fields&gt;
}
</pre>

The name field is required, and must be set to a valid terrain, sound, frame, or thingtype 
mnemonic in order to specify the definition that the delta structure edits. Along with the 
name, the delta structure can specify any field that is valid in that type of definition 
(see exceptions below). 
<br><br>
See the
<a href="#frames">Frames</a>, <a href="#things">Thing Types</a>, <a href="#sound">Sounds</a>, 
and <a href="#terrain">Terrain</a> sections for full information on their fields and syntax.
<br><br>
Any field not specified in a delta structure will not be affected, and retains the value that
it had before the delta structure was applied.  A delta structure must specify values
explicitly, even if the new values are the usual defaults for those fields. Note that the
frame args list must be completely specified. It is not possible to override only some of the
values in that list.
<br><br>
Fields not supported in delta structures:
<ul>
<li> The <b>dehackednum</b> field of any section edited by a delta structure cannot be changed.
     Although the field will be syntactically accepted by the parser, any value provided to it
     in a delta structure will have no effect. Only definition sections can provide a DeHackEd
     number.
<li> The <b>cmp</b> field of the <b>frame</b> block is not supported in <b>framedelta</b> sections.
<li> The <b>inherits</b> field of the <b>thingtype</b> block is not supported in <b>thingdelta</b> sections.
</ul>

Frame Delta Example:
<pre>
# Change the Zombieman attack frame to use the shotgun zombie attack
framedelta
{
   name = S_POSS_ATK2
   action = SPosAttack
}
</pre>
Thing Delta Example:
<pre>
# Change the Zombieman's drop type to MegaSphere, and his spawnhealth to 400
thingdelta
{
   name = Zombieman
   droptype = MegaSphere
   spawnhealth = 400
}


# Later on, maybe in a different file, we change the spawnhealth again
thingdelta
{
   name = Zombieman
   spawnhealth = 20
}

# At this point, the Zombieman drops MegaSpheres, but his spawnhealth is 20, not 400.
</pre>
Sound Delta Example:
<pre>
# This changes the sound explod we defined earlier
sounddelta
{
   name = explod
   priority = 200
   singularity = sg_getpow
}
</pre>
Terrain Delta Example:
<pre>
# Terrain deltas used by Heretic in terrain.edf to enable splash alerts:
terraindelta { name = Water;  splashalert = true }
terraindelta { name = Lava;   splashalert = true }
terraindelta { name = Sludge; splashalert = true }
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="misc">
<hr>
<b>Miscellaneous Settings</b>
<hr>
</a>
<br>
These optional settings allow customization of various game engine behaviors. When not
provided, they take on the indicated default values. All of these options can only be
specified in the topmost level of an EDF file. The last definition encountered is the
one which will be used.
<br><br>
<ul>
<li><b>doom2_title_tics</b><br>
    Default: 385 (11 seconds)<br>
    This variable allows you to change the length of time for which the DOOM II title screen
    is displayed. This is useful if your title song needs to be longer or shorter than the
    original. The unit for this variable is tics (35 per second).<br>
    Example:
    <pre>
    doom2_title_tics = 525    # make the DOOM II title screen last 15 seconds
    </pre>
<li><b>intermission_pause</b><br>
    Default: 0<br>
    This variable allows you to specify a period of time in gametics that the DOOM/DOOM II 
    statistics intermission will pause while displaying the background picture. After the
    pause period has expired, the intermission will resume as normal by displaying the map
    name and statistics.<br>
    Example:
    <pre>
    intermission_pause = 70  # wait for 2 seconds
    </pre>
<li><b>intermission_fade</b><br>
    Default: None<br>
    This variable allows you to specify a color which will be overlaid on the background
    picture in the DOOM/DOOM II statistics intermission once the optional pause period has
    expired. If no pause period is specified, the color overlay will appear immediately at 
    the start of the intermission. The value accepted by this variable is a palette index,
    which will be clamped into the range of 0 to 255.<br>
    Example:
    <pre>
    intermission_fade = 0  # Fade to Black (dun dun dun dun...)
    </pre>
<li><b>intermission_tl</b><br>
    Default: 0%<br>
    This variable specifies the translucency value with which the fade color will be
    overlaid on the background picture when an intermission fade color is specified.
    This field can accept an integer between 0 and 65536, or a percentage value. A percentage
    value must be a base 10 integer between 0 and 100 followed immediately by a % character.
</ul>
<a href="#contents">Return to Table of Contents</a>

</body>
</html>







